#! /bin/bash

# The MIT License (MIT)
# written by Andreas Vollrath, 2017

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished
# to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

function s1_frame_import() {
  if [ -z "$3" ]; then
    echo " Missing arguments. Syntax:"
    echo " s1_frame_import <input_file> <output_file> <log_dir>"
    return
  fi

  # source other helpers
  source ${OPENSARKIT}/lib/helpers_source

  # error codes
  ERR_IMPORT="Error during clean import of product"

  BASE=`basename $1`
  echo ""
  SECONDS=0
  echo -ne " Importing S1 GRD data file, applying the precise orbit file and removing thermal noise ..." &&
  bash ${SNAP_EXE} ${S1_GRD_import_GRAPHS}/S1_GRD_AO_TNR.xml -x -Pinput=$1 -Poutput=$2 > $3/log_import 2>&1
  duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

  SECONDS=0
  echo -ne " Removing GRD Border Noise ..." &&
  FILE_NAME=$2
  cp ${FILE_NAME}.data/Intensity_VV.hdr ${FILE_NAME}.data/Intensity_VV.orig.hdr
  ost_remove_border.py -i ${FILE_NAME}.data/Intensity_VV.img -o ${FILE_NAME}.data/Intensity_VV.img > $3/log_import 2>&1
  mv ${FILE_NAME}.data/Intensity_VV.orig.hdr ${FILE_NAME}.data/Intensity_VV.hdr

  if [[ -e ${FILE_NAME}.data/Intensity_VH.img ]];then
    cp ${FILE_NAME}.data/Intensity_VH.hdr ${FILE_NAME}.data/Intensity_VH.orig.hdr
    ost_remove_border.py -i ${FILE_NAME}.data/Intensity_VH.img -o ${FILE_NAME}.data/Intensity_VH.img > $3/log_import 2>&1
    mv ${FILE_NAME}.data/Intensity_VH.orig.hdr ${FILE_NAME}.data/Intensity_VH.hdr
  fi
  duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
  [ $? -ne 0 ] && return ${ERR_IMPORT}

}

function s1_swath_import() {
  if [ -z "$4" ]; then
    echo " Missing arguments. Syntax:"
    echo " s1_swath_preprocess <filelist> <output_file> <tmp_dir> <log_dir>"
    return
  fi

  # source other helpers
  source ${OPENSARKIT}/lib/helpers_source

  # error codes
  ERR_IMPORT="Error during clean import of product"
  ERR_BRD_NOISE="Error during border noise removal"
  ERR_TF="Error during Terrain Flattening"
  ERR_TC="Error during geometric terrain correction"

  NR_OF_FRAMES=`cat $1 | wc -l`
  j=1

  for LINE in `cat $1`;do
    s1_info ${LINE}
    BASE=`basename ${LINE}`
    echo ""
    SECONDS=0
    echo -ne " Importing S1 GRD data file, applying the precise orbit file and removing thermal noise ..." &&
    bash ${SNAP_EXE} ${S1_GRD_import_GRAPHS}/S1_GRD_AO_TNR.xml -x -Pinput=${LINE} -Poutput=$3/${BASE}-import > $4/log_import 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_IMPORT}

    SECONDS=0
    echo -ne " Removing GRD Border Noise ..." &&
    FILE_NAME="$3/${BASE}-import"
    cp ${FILE_NAME}.data/Intensity_VV.hdr ${FILE_NAME}.data/Intensity_VV.orig.hdr
    ost_remove_border.py -i ${FILE_NAME}.data/Intensity_VV.img -o ${FILE_NAME}.data/Intensity_VV.img >> $4/log_import 2>&1
    mv ${FILE_NAME}.data/Intensity_VV.orig.hdr ${FILE_NAME}.data/Intensity_VV.hdr

    if [[ -e ${FILE_NAME}.data/Intensity_VH.img ]];then
      cp ${FILE_NAME}.data/Intensity_VH.hdr ${FILE_NAME}.data/Intensity_VH.orig.hdr
      ost_remove_border.py -i ${FILE_NAME}.data/Intensity_VH.img -o ${FILE_NAME}.data/Intensity_VH.img >> $4/log_import 2>&1
      mv ${FILE_NAME}.data/Intensity_VH.orig.hdr ${FILE_NAME}.data/Intensity_VH.hdr
    fi
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    echo " Finished import of Frame: $j/${NR_OF_FRAMES}"
    j=`expr $j + 1`
  done

  if [ -e $3/${BASE}-import.data/Intensity_VH.img ];then

    SECONDS=0
    echo -ne " Assembling the products of the same swath ..." &&
    bash $SNAP_EXE SliceAssembly -PselectedPolarisations=VV,VH $(ls -1 $3/*-import.dim | tr '\n' ' ' | rev | cut -c 2- | rev) -t $2 > $4/log_swath_assembly 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_ASSEMBLE}
    rm -rf $3/*-import.d*

  else

    SECONDS=0
    echo -ne " Assembling the products of the same swath ..." &&
    bash $SNAP_EXE SliceAssembly -PselectedPolarisations=VV $(ls -1 $3/*-import.dim | tr '\n' ' ' | rev | cut -c 2- | rev) -t $2 > $4/log_swath_assembly 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_ASSEMBLE}
    rm -rf $3/*-import.d*
  fi
}

function s1_rtc_processing() {
  if [ -z "$7" ]; then
    echo " Missing arguments. Syntax:"
    echo " s1_rtc_processing <input file> <output_file> <resolution> <mode> <aoi> <tmp_dir> <log_dir>"
    return
  fi


  BASE=`echo $1 | rev | cut -c 5- | rev`
  RTC_IN="$1"
  RTC_OUT="$2"
  RTC_RES="$3"
  RTC_MODE="$4"
  RTC_AOI="$5"
  RTC_TMP="$6"
  RTC_LOG="$7"

  NR_OF_CPUS=`echo "$(nproc) * 2" | bc`

  if [ ${RTC_RES} == "MED_RES" ];then

    SECONDS=0
    echo -ne " Calibrating to beta0, applying the terrain flattening and multi-look by a factor of 3  ..." &&
    bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_CAL_TF_ML3.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_IN} -Poutput=${RTC_TMP}/TF > ${RTC_LOG}/log_cal_tf_ml 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_BRD_NOISE}

    SECONDS=0
    echo -ne " Creating a layover/shadow mask ... " &&
    bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_LayShaMask_ML3.xml -x  -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_OUT}.LS_mask >> ${RTC_LOG}/log_cal_tf_ml 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

    if [ -e ${RTC_TMP}/TF.data/Gamma0_VH.img ];then

      if [[ ${RTC_MODE} == 0 ]];then # db scale + ratio

        SECONDS=0
        echo -ne " Applying the geometric terrain correction, calculate the VV/VH Band Ratio and transform backscatter to decibel scale  ..." &&
        bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_SDV_30_TC_DB_Ratio.xml -x  -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_TMP}/TC_DB -PoutputRatio=${RTC_TMP}/Ratio > ${RTC_LOG}/log_tc_ratio 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${RTC_TMP}/TF.d*

        SECONDS=0
        echo -ne " Merging backscatter bands with ratio"
        bash ${SNAP_EXE} BandMerge -x  -q ${NR_OF_CPUS} ${RTC_TMP}/TC_DB.dim ${RTC_TMP}/Ratio.dim -t ${RTC_TMP}/RTC.dim > ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_BM}
        rm -rf ${RTC_TMP}/TC_DB.d* ${RTC_TMP}/Ratio.d*

        SECONDS=0
        echo -ne " Creating final output file ..." &&
        gdalbuildvrt -separate -srcnodata 0 ${RTC_TMP}/rgb.vrt ${RTC_TMP}/RTC.data/Gamma0_VV_db.img ${RTC_TMP}/RTC.data/Gamma0_VH_db.img ${RTC_TMP}/RTC.data/VV-VH_ratio.img >> ${RTC_LOG}/log_output 2>&1

        gdal_calc.py --overwrite -A ${RTC_TMP}/RTC.data/Gamma0_VV_db.img --outfile=${RTC_TMP}/Gamma0.db.clean.tif --calc="A*(A>=-30)" --co="BIGTIFF=YES"
        gdal_trace_outline ${RTC_TMP}/Gamma0.db.clean.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${RTC_TMP}/valid.shp >> ${RTC_LOG}/log_output 2>&1

        # create intersect of image extent and AOI
        ogr2ogr -F "ESRI Shapefile" ${RTC_TMP}/extent_buf.shp ${RTC_TMP}/valid.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.001) from valid"
        EXTENT="${RTC_TMP}/extent_buf.shp"
        CROPLINE=${RTC_TMP}/cropline.shp

        if [[ -e ${RTC_AOI} ]];then
          intersect_shp ${EXTENT} ${RTC_AOI} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          CROPLINE=${EXTENT}
        fi

        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "COMPRESS=LZW" -co "BIGTIFF=YES" ${RTC_TMP}/rgb.vrt ${RTC_TMP}/RTC_final.tif >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        rm -rf ${RTC_TMP}/RTC.d* ${RTC_TMP}/rgb.vrt

        SECONDS=0
        echo -ne " Mask out layover/shadow areas ..." &&
        gdal_edit.py -a_nodata 0 ${RTC_OUT}.LS_mask.data/layover_shadow_mask_VH.img
        gdal_fillnodata.py -md 3 ${RTC_OUT}.LS_mask.data/layover_shadow_mask_VH.img ${RTC_TMP}/LS.map.max.nd.closed.tif >> ${RTC_LOG}/log_output 2>&1
        rm -rf ${RTC_OUT}.LS_mask.d*
        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "BIGTIFF=YES" ${RTC_TMP}/LS.map.max.nd.closed.tif ${RTC_TMP}/LS.map.tif >> ${RTC_LOG}/log_output 2>&1
        gdal_edit.py -unsetnodata ${RTC_TMP}/LS.map.tif # >> ${RTC_LOG}/log_m t_stacking 2>&1
        gdal_calc.py --overwrite --type='Byte' -A ${RTC_TMP}/LS.map.tif --outfile=${RTC_OUT}.LS.map.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${RTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${RTC_OUT}.LS.map.tif -B ${RTC_TMP}/RTC_final.tif --allBands=B --outfile=${RTC_OUT}.RTC.tif --calc="A*B" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        SECONDS=0
        echo -ne " Create a kmz file for Google Earth Visualization ..." &&
        gdal_contrast_stretch -ndv 0 -percentile-range 0.01 0.99 ${RTC_OUT}.RTC.tif ${RTC_TMP}/RTC.8bit.tif >> ${RTC_LOG}/log_output 2>&1
        gdal_translate -of KMLSUPEROVERLAY ${RTC_TMP}/RTC.8bit.tif ${RTC_OUT}.RTC.kmz -co format=JPEG >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

      elif [[ ${RTC_MODE} == 1 ]];then # db scale + ratio

        SECONDS=0 # no db-scaling
        echo -ne " Applying the geometric terrain correction ..." &&
        bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_SDV_30_TC.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_OUT}.RTC > ${RTC_LOG}/log_tc 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${RTC_TMP}/TF.d*

      fi

    else # SSV 30m

      if [[ ${RTC_MODE} == 0 ]];then # db scaling

        SECONDS=0
        echo -ne " Applying the geometric terrain correction and transform backscatter to decibel scale  ..." &&
        bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_SSV_30_TC_DB.xml -x  -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_TMP}/RTC > ${RTC_LOG}/log_tc_db 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${RTC_TMP}/TF.d*

        SECONDS=0
        echo -ne " Creating final output file ..." &&
        gdal_calc.py --overwrite -A ${RTC_TMP}/RTC.data/Gamma0_VV_db.img --outfile=${RTC_TMP}/Gamma0.db.clean.tif --calc="A*(A>=-30)" --co="BIGTIFF=YES"
        gdal_trace_outline ${RTC_TMP}/Gamma0.db.clean.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${RTC_TMP}/valid.shp >> ${RTC_LOG}/log_output 2>&1

        # create intersect of image extent and AOI
        ogr2ogr -F "ESRI Shapefile" ${RTC_TMP}/extent_buf.shp ${RTC_TMP}/valid.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.001) from valid"
        EXTENT=${RTC_TMP}/extent_buf.shp
        CROPLINE=${RTC_TMP}/cropline.shp

        if [[ -e ${RTC_AOI} ]];then
          intersect_shp ${EXTENT} ${RTC_AOI} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          CROPLINE=${EXTENT}
        fi

        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "COMPRESS=LZW" -co "BIGTIFF=YES" ${RTC_TMP}/RTC.data/Gamma0_VV_db.img ${RTC_TMP}/RTC_final.tif >> ${RTC_LOG}/log_output 2>&1 >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        rm -rf ${RTC_TMP}/RTC.d*

        SECONDS=0
        echo -ne " Mask out layover/shadow areas ..." &&
        gdal_edit.py -a_nodata 0 ${RTC_OUT}.LS_mask.data/layover_shadow_mask_VV.img
        gdal_fillnodata.py -md 3 ${RTC_OUT}.LS_mask.data/layover_shadow_mask_VV.img ${RTC_TMP}/LS.map.max.nd.closed.tif >> ${RTC_LOG}/log_output 2>&1
        rm -rf ${RTC_OUT}.LS_mask.d*
        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "BIGTIFF=YES" ${RTC_TMP}/LS.map.max.nd.closed.tif ${RTC_TMP}/LS.map.tif >> ${RTC_LOG}/log_output 2>&1
        gdal_edit.py -unsetnodata ${RTC_TMP}/LS.map.tif # >> ${RTC_LOG}/log_mt_stacking 2>&1
        gdal_calc.py --overwrite --type='Byte' -A ${RTC_TMP}/LS.map.tif --outfile=${RTC_OUT}.LS.map.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${RTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${RTC_OUT}.LS.map.tif -B ${RTC_TMP}/RTC_final.tif --allBands=B --outfile=${RTC_OUT}.RTC.tif --calc="A*B" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        SECONDS=0
        echo -ne " Create a kmz file for Google Earth Visualization ..." &&
        gdal_contrast_stretch -ndv 0 -percentile-range 0.01 0.99 ${RTC_OUT}.RTC.tif ${RTC_TMP}/RTC.8bit.tif >> ${RTC_LOG}/log_output 2>&1
        gdal_translate -of KMLSUPEROVERLAY ${RTC_TMP}/RTC.8bit.tif ${RTC_OUT}.RTC.kmz -co format=JPEG >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

      else

        SECONDS=0 # no db-scaling
        echo -ne " Applying the geometric terrain correction ..." &&
        bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_SSV_30_TC.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_OUT}.RTC > ${RTC_LOG}/log_tc 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return  ${ERR_TC}
        rm -rf ${RTC_TMP}/TF.d*

      fi

    fi

  elif [ ${RTC_RES} == "HI_RES" ];then

    SECONDS=0
    echo " Removing GRD border noise by deleting the outer 600 rows, calibrating to beta0, "
    echo -ne " applying the terrain flattening ..." &&
    bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_CAL_TF_noML.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_IN} -Pwidth=${NEW_WIDTH} -Pheight=${NEW_HEIGHT} -Poutput=${RTC_TMP}/TF > ${RTC_LOG}/log_cal_tf 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_BRD_NOISE}
    rm -rf ${RTC_TMP}/${BASE}-import.dim

    SECONDS=0
    echo -ne " Creating a layover/shadow mask ... " &&
    bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_LayShaMask_noML.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_OUT}.LS_mask  >> ${RTC_LOG}/log_cal_tf_ml 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"


    if [ -e ${RTC_TMP}/TF.data/Gamma0_VH.img ];then

      if [[ ${RTC_MODE} == 0 ]];then # db scale + ratio

        SECONDS=0
        echo -ne " Applying the geometric terrain correction, calculate the VV/VH Band Ratio and transform backscatter to decibel scale  ..." &&
        bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_SDV_10_TC_DB_Ratio.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_TMP}/TC_DB -PoutputRatio=${RTC_TMP}/Ratio > ${RTC_LOG}/log_tc_ratio 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${RTC_TMP}/TF.d*

        SECONDS=0
        echo -ne " Merging backscatter bands with ratio"
        bash ${SNAP_EXE} BandMerge -x -q ${NR_OF_CPUS} ${RTC_TMP}/TC_DB.dim ${RTC_TMP}/Ratio.dim -t ${RTC_TMP}/RTC.dim > ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_BM}
        rm -rf ${RTC_TMP}/TC_DB.d* ${RTC_TMP}/Ratio.d*

        SECONDS=0
        echo -ne " Creating final output file ..." &&
        gdalbuildvrt -separate -srcnodata 0 ${RTC_TMP}/rgb.vrt ${RTC_TMP}/RTC.data/Gamma0_VV_db.img ${RTC_TMP}/RTC.data/Gamma0_VH_db.img ${RTC_TMP}/RTC.data/VV-VH_ratio.img >> ${RTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${RTC_TMP}/RTC.data/Gamma0_VV_db.img --outfile=${RTC_TMP}/Gamma0.db.clean.tif --calc="A*(A>=-30)" --co="BIGTIFF=YES"
        gdal_trace_outline ${RTC_TMP}/Gamma0.db.clean.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${RTC_TMP}/valid.shp >> ${RTC_LOG}/log_output 2>&1

        # create intersect of image extent and AOI
        ogr2ogr -F "ESRI Shapefile" ${RTC_TMP}/extent_buf.shp ${RTC_TMP}/valid.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.001) from valid"
        EXTENT="${RTC_TMP}/extent_buf.shp"
        CROPLINE=${RTC_TMP}/cropline.shp

        if [[ -e ${RTC_AOI} ]];then
          intersect_shp ${EXTENT} ${RTC_AOI} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          CROPLINE=${EXTENT}
        fi

        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "COMPRESS=LZW" -co "BIGTIFF=YES" ${RTC_TMP}/rgb.vrt ${RTC_TMP}/RTC_final.tif >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        rm -rf ${RTC_TMP}/RTC.d* ${RTC_TMP}/rgb.vrt

        SECONDS=0
        echo -ne " Mask out layover/shadow areas ..." &&
        gdal_edit.py -a_nodata 0 ${RTC_OUT}.LS_mask.data/layover_shadow_mask_VH.img
        gdal_fillnodata.py -md 3 ${RTC_OUT}.LS_mask.data/layover_shadow_mask_VH.img ${RTC_TMP}/LS.map.max.nd.closed.tif >> ${RTC_LOG}/log_output 2>&1
        rm -rf ${RTC_OUT}.LS_mask.d*
        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "BIGTIFF=YES" ${RTC_TMP}/LS.map.max.nd.closed.tif ${RTC_TMP}/LS.map.tif >> ${RTC_LOG}/log_output 2>&1
        gdal_edit.py -unsetnodata ${RTC_TMP}/LS.map.tif # >> ${RTC_LOG}/log_mt_stacking 2>&1
        gdal_calc.py --overwrite --type='Byte' -A ${RTC_TMP}/LS.map.tif --outfile=${RTC_OUT}.LS.map.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${RTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${RTC_OUT}.LS.map.tif -B ${RTC_TMP}/RTC_final.tif --allBands=B --outfile=${RTC_OUT}.RTC.tif --calc="A*B" --NoDataValue=0 --co='COMPRESS=LZW'  --co="BIGTIFF=YES" >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        SECONDS=0
        echo -ne " Create a kmz file for Google Earth Visualization ..." &&
        gdal_contrast_stretch -ndv 0 -percentile-range 0.01 0.99 ${RTC_OUT}.RTC.tif ${RTC_TMP}/RTC.8bit.tif >> ${RTC_LOG}/log_output 2>&1
        gdal_translate -of KMLSUPEROVERLAY ${RTC_TMP}/RTC.8bit.tif ${RTC_OUT}.RTC.kmz -co format=JPEG >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

      elif [[ ${RTC_MODE} == 1 ]];then #neither db nor ratio calculation

          SECONDS=0
          echo -ne " Applying the geometric terrain correction ..." &&
          bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_SDV_10_TC.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_OUT}.RTC > ${RTC_LOG}/log_tc 2>&1
          duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
          [ $? -ne 0 ] && return ${ERR_TC}
          rm -rf ${RTC_TMP}/TF.d*

      fi

    else # SSV 10m case

      if [[ ${RTC_MODE} == 0 ]];then

        SECONDS=0
        echo -ne " Applying the geometric terrain correction and transform backscatter to decibel scale  ..." &&
        bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_SSV_10_TC_DB.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_TMP}/RTC > ${RTC_LOG}/log_tc_db 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${RTC_TMP}/TF.d*

        SECONDS=0
        echo -ne " Creating final output file ..." &&
        gdal_calc.py --overwrite -A ${RTC_TMP}/RTC.data/Gamma0_VV_db.img --outfile=${RTC_TMP}/Gamma0.db.clean.tif --calc="A*(A>=-30)" --co="BIGTIFF=YES"
        gdal_trace_outline ${RTC_TMP}/Gamma0.db.clean.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${RTC_TMP}/valid.shp >> ${RTC_LOG}/log_output 2>&1

        # create intersect of image extent and AOI
        ogr2ogr -F "ESRI Shapefile" ${RTC_TMP}/extent_buf.shp ${RTC_TMP}/valid.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.001) from valid"
        EXTENT=${RTC_TMP}/extent_buf.shp
        CROPLINE=${RTC_TMP}/cropline.shp

        if [[ -e ${RTC_AOI} ]];then
          intersect_shp ${EXTENT} ${RTC_AOI} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          CROPLINE=${EXTENT}
        fi

        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "COMPRESS=LZW" -co "BIGTIFF=YES"  ${RTC_TMP}/RTC.data/Gamma0_VV_db.img ${RTC_TMP}/RTC_final.tif >> ${RTC_LOG}/log_output 2>&1 >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        rm -rf ${RTC_TMP}/RTC.d*

        SECONDS=0
        echo -ne " Mask out layover/shadow areas ..." &&
        gdal_edit.py -a_nodata 0 ${RTC_OUT}.LS_mask.data/layover_shadow_mask_VV.img
        gdal_fillnodata.py -md 3 ${RTC_OUT}.LS_mask.data/layover_shadow_mask_VV.img ${RTC_TMP}/LS.map.max.nd.closed.tif >> ${RTC_LOG}/log_output 2>&1
        rm -rf ${RTC_OUT}.LS_mask.d*
        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "BIGTIFF=YES" ${RTC_TMP}/LS.map.max.nd.closed.tif ${RTC_TMP}/LS.map.tif >> ${RTC_LOG}/log_output 2>&1

        gdal_edit.py -unsetnodata ${RTC_TMP}/LS.map.tif # >> ${RTC_LOG}/log_mt_stacking 2>&1
        gdal_calc.py --overwrite --type='Byte' -A ${RTC_TMP}/LS.map.tif --outfile=${RTC_OUT}.LS.map.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES" >> ${RTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${RTC_OUT}.LS.map.tif -B ${RTC_TMP}/RTC_final.tif --allBands=B --outfile=${RTC_OUT}.RTC.tif --calc="A*B" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES" >> ${RTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        SECONDS=0
        echo -ne " Create a kmz file for Google Earth Visualization ..." &&
        gdal_contrast_stretch -ndv 0 -percentile-range 0.01 0.99 ${RTC_OUT}.RTC.tif ${RTC_TMP}/RTC.8bit.tif >> ${RTC_LOG}/log_kmz 2>&1
        gdal_translate -of KMLSUPEROVERLAY ${RTC_TMP}/RTC.8bit.tif ${RTC_OUT}.RTC.kmz -co format=JPEG >> ${RTC_LOG}/log_kmz 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
      else


        SECONDS=0
        echo -ne " Applying the geometric terrain correction ..." &&
        bash ${SNAP_EXE} ${S1_GRD2RTC_GRAPHS}/S1_GRD2RTC_SSV_10_TC.xml -x -q ${NR_OF_CPUS} -Pinput=${RTC_TMP}/TF.dim -Poutput=${RTC_OUT}.RTC > ${RTC_LOG}/log_tc 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${RTC_TMP}/TF.d*

      fi

    fi
  fi

  echo "------------------------------------------------------------------------------------------------------"
  echo " Info: Succesfully processed file: `basename ${RTC_IN}` to a radiometrically terrain corrected product. "
  echo "------------------------------------------------------------------------------------------------------"
  echo ""

}

function s1_gtc_processing() {
  if [ -z "$7" ]; then
    echo " Missing arguments. Syntax:"
    echo " s1_gtc_processing <input file> <output_file> <resolution> <mode> <aoi> <tmp_dir> <log_dir>"
    return
  fi


  BASE=`echo $1 | rev | cut -c 5- | rev`
  GTC_IN="$1"
  GTC_OUT="$2"
  GTC_RES="$3"
  GTC_MODE="$4"
  GTC_AOI="$5"
  GTC_TMP="$6"
  GTC_LOG="$7"

  NR_OF_CPUS=`echo "$(nproc) * 2" | bc`

  if [ ${GTC_RES} == "MED_RES" ];then

    SECONDS=0
    echo -ne " Calibrating to Gamma0 (based on ellipsoid earth model) and multi-look by a factor of 3 ..." &&
    bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_CAL_ML3.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_IN} -Poutput=${GTC_TMP}/TF  > ${GTC_LOG}/log_cal_ml 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_BRD_NOISE}

    SECONDS=0
    echo -ne " Creating a layover/shadow mask ... " &&
    bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_LayShaMask_ML3.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_OUT}.LS_mask  > ${GTC_LOG}/log_ls_mask 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

    if [ -e ${GTC_TMP}/TF.data/Gamma0_VH.img ];then

      if [[ ${GTC_MODE} == 0 ]];then # db scale + ratio

        SECONDS=0
        echo -ne " Applying the geometric terrain correction, calculate the VV/VH Band Ratio and transform backscatter to decibel scale  ..." &&
        bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_SDV_30_TC_DB_Ratio.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_TMP}/TC_DB -PoutputRatio=${GTC_TMP}/Ratio > ${GTC_LOG}/log_tc_ratio 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${GTC_TMP}/TF.d*

        SECONDS=0
        echo -ne " Merging backscatter bands with ratio"
        bash ${SNAP_EXE} BandMerge -x -q ${NR_OF_CPUS} ${GTC_TMP}/TC_DB.dim ${GTC_TMP}/Ratio.dim -t ${GTC_TMP}/GTC.dim > ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_BM}
        rm -rf ${GTC_TMP}/TC_DB.d* ${GTC_TMP}/Ratio.d*

        SECONDS=0
        echo -ne " Creating final output file ..." &&
        gdalbuildvrt -separate -srcnodata 0 ${GTC_TMP}/rgb.vrt ${GTC_TMP}/GTC.data/Gamma0_VV_db.img ${GTC_TMP}/GTC.data/Gamma0_VH_db.img ${GTC_TMP}/GTC.data/VV-VH_ratio.img >> ${GTC_LOG}/log_output 2>&1

        gdal_calc.py --overwrite -A ${GTC_TMP}/GTC.data/Gamma0_VV_db.img --outfile=${GTC_TMP}/Gamma0.db.clean.tif --calc="A*(A>=-30)" --co="BIGTIFF=YES"
        gdal_trace_outline ${GTC_TMP}/Gamma0.db.clean.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${GTC_TMP}/valid.shp >> ${GTC_LOG}/log_output 2>&1

        # create intersect of image extent and AOI
        ogr2ogr -F "ESRI Shapefile" ${GTC_TMP}/extent_buf.shp ${GTC_TMP}/valid.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.001) from valid"
        EXTENT="${GTC_TMP}/extent_buf.shp"
        CROPLINE=${GTC_TMP}/cropline.shp

        if [[ -e ${GTC_AOI} ]];then
          intersect_shp ${EXTENT} ${GTC_AOI} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          CROPLINE=${EXTENT}
        fi

        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "COMPRESS=LZW" -co "BIGTIFF=YES" ${GTC_TMP}/rgb.vrt ${GTC_TMP}/GTC_final.tif >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        rm -rf ${GTC_TMP}/GTC.d* ${GTC_TMP}/rgb.vrt

        SECONDS=0
        echo -ne " Mask out layover/shadow areas ..." &&
        gdal_edit.py -a_nodata 0 ${GTC_OUT}.LS_mask.data/layover_shadow_mask_VH.img
        gdal_fillnodata.py -md 3 ${GTC_OUT}.LS_mask.data/layover_shadow_mask_VH.img ${GTC_TMP}/LS.map.max.nd.closed.tif >> ${GTC_LOG}/log_output 2>&1
        rm -rf ${GTC_OUT}.LS_mask.d*
        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "BIGTIFF=YES" ${GTC_TMP}/LS.map.max.nd.closed.tif ${GTC_TMP}/LS.map.tif >> ${GTC_LOG}/log_output 2>&1
        gdal_edit.py -unsetnodata ${GTC_TMP}/LS.map.tif # >> ${GTC_LOG}/log_m t_stacking 2>&1
        gdal_calc.py --overwrite --type='Byte' -A ${GTC_TMP}/LS.map.tif --outfile=${GTC_OUT}.LS.map.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${GTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${GTC_OUT}.LS.map.tif -B ${GTC_TMP}/GTC_final.tif --allBands=B --outfile=${GTC_OUT}.GTC.tif --calc="A*B" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        SECONDS=0
        echo -ne " Create a kmz file for Google Earth Visualization ..." &&
        gdal_contrast_stretch -ndv 0 -percentile-range 0.02 0.98 ${GTC_OUT}.GTC.tif ${GTC_TMP}/GTC.8bit.tif >> ${GTC_LOG}/log_output 2>&1
        gdal_translate -of KMLSUPEROVERLAY ${GTC_TMP}/GTC.8bit.tif ${GTC_OUT}.GTC.kmz -co format=JPEG >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

      elif [[ ${GTC_MODE} == 1 ]];then # db scale + ratio

        SECONDS=0 # no db-scaling
        echo -ne " Applying the geometric terrain correction ..." &&
        bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_SDV_30_TC.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_OUT}.GTC > ${GTC_LOG}/log_tc 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${GTC_TMP}/TF.d*

      fi

    else # SSV 30m

      if [[ ${GTC_MODE} == 0 ]];then # db scaling

        SECONDS=0
        echo -ne " Applying the geometric terrain correction and transform backscatter to decibel scale  ..." &&
        bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_SSV_30_TC_DB.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_TMP}/GTC > ${GTC_LOG}/log_tc_db 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${GTC_TMP}/TF.d*

        SECONDS=0
        echo -ne " Creating final output file ..." &&
        gdal_calc.py --overwrite -A ${GTC_TMP}/GTC.data/Gamma0_VV_db.img --outfile=${GTC_TMP}/Gamma0.db.clean.tif --calc="A*(A>=-30)" --co="BIGTIFF=YES"
        gdal_trace_outline ${GTC_TMP}/Gamma0.db.clean.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${GTC_TMP}/valid.shp >> ${GTC_LOG}/log_output 2>&1

        # create intersect of image extent and AOI
        ogr2ogr -F "ESRI Shapefile" ${GTC_TMP}/extent_buf.shp ${GTC_TMP}/valid.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.001) from valid"
        EXTENT=${GTC_TMP}/extent_buf.shp
        CROPLINE=${GTC_TMP}/cropline.shp

        if [[ -e ${GTC_AOI} ]];then
          intersect_shp ${EXTENT} ${GTC_AOI} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          CROPLINE=${EXTENT}
        fi

        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "COMPRESS=LZW" -co "BIGTIFF=YES" ${GTC_TMP}/GTC.data/Gamma0_VV_db.img ${GTC_TMP}/GTC_final.tif >> ${GTC_LOG}/log_output 2>&1 >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        rm -rf ${GTC_TMP}/GTC.d*

        SECONDS=0
        echo -ne " Mask out layover/shadow areas ..." &&
        gdal_edit.py -a_nodata 0 ${GTC_OUT}.LS_mask.data/layover_shadow_mask_VV.img
        gdal_fillnodata.py -md 3 ${GTC_OUT}.LS_mask.data/layover_shadow_mask_VV.img ${GTC_TMP}/LS.map.max.nd.closed.tif >> ${GTC_LOG}/log_output 2>&1
        rm -rf ${GTC_OUT}.LS_mask.d*
        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "BIGTIFF=YES" ${GTC_TMP}/LS.map.max.nd.closed.tif ${GTC_TMP}/LS.map.tif >> ${GTC_LOG}/log_output 2>&1
        gdal_edit.py -unsetnodata ${GTC_TMP}/LS.map.tif # >> ${GTC_LOG}/log_mt_stacking 2>&1
        gdal_calc.py --overwrite --type='Byte' -A ${GTC_TMP}/LS.map.tif --outfile=${GTC_OUT}.LS.map.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${GTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${GTC_OUT}.LS.map.tif -B ${GTC_TMP}/GTC_final.tif --allBands=B --outfile=${GTC_OUT}.GTC.tif --calc="A*B" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        SECONDS=0
        echo -ne " Create a kmz file for Google Earth Visualization ..." &&
        gdal_contrast_stretch -ndv 0 -percentile-range 0.02 0.98 ${GTC_OUT}.GTC.tif ${GTC_TMP}/GTC.8bit.tif >> ${GTC_LOG}/log_output 2>&1
        gdal_translate -of KMLSUPEROVERLAY ${GTC_TMP}/GTC.8bit.tif ${GTC_OUT}.GTC.kmz -co format=JPEG >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

      else

        SECONDS=0 # no db-scaling
        echo -ne " Applying the geometric terrain correction ..." &&
        bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_SSV_30_TC.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_OUT}.GTC > ${GTC_LOG}/log_tc 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return  ${ERR_TC}
        rm -rf ${GTC_TMP}/TF.d*

      fi

    fi

  elif [ ${GTC_RES} == "HI_RES" ];then

    SECONDS=0
    echo " Removing GRD border noise by deleting the outer 600 rows, calibrating to beta0, "
    echo -ne " applying the terrain flattening ..." &&
    bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_CAL_noML.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_IN} -Pwidth=${NEW_WIDTH} -Pheight=${NEW_HEIGHT} -Poutput=${GTC_TMP}/TF > ${GTC_LOG}/log_cal_tf 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_BRD_NOISE}
    rm -rf ${GTC_TMP}/${BASE}-import.dim

    SECONDS=0
    echo -ne " Creating a layover/shadow mask ... " &&
    bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_LayShaMask_noML.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_OUT}.LS_mask  > ${GTC_LOG}/log_cal_tf_ml 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"


    if [ -e ${GTC_TMP}/TF.data/Gamma0_VH.img ];then

      if [[ ${GTC_MODE} == 0 ]];then # db scale + ratio

        SECONDS=0
        echo -ne " Applying the geometric terrain correction, calculate the VV/VH Band Ratio and transform backscatter to decibel scale  ..." &&
        bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_SDV_10_TC_DB_Ratio.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_TMP}/TC_DB -PoutputRatio=${GTC_TMP}/Ratio > ${GTC_LOG}/log_tc_ratio 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${GTC_TMP}/TF.d*

        SECONDS=0
        echo -ne " Merging backscatter bands with ratio"
        bash ${SNAP_EXE} BandMerge -x -q ${NR_OF_CPUS} ${GTC_TMP}/TC_DB.dim ${GTC_TMP}/Ratio.dim -t ${GTC_TMP}/GTC.dim > ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_BM}
        rm -rf ${GTC_TMP}/TC_DB.d* ${GTC_TMP}/Ratio.d*

        SECONDS=0
        echo -ne " Creating final output file ..." &&
        gdalbuildvrt -separate -srcnodata 0 ${GTC_TMP}/rgb.vrt ${GTC_TMP}/GTC.data/Gamma0_VV_db.img ${GTC_TMP}/GTC.data/Gamma0_VH_db.img ${GTC_TMP}/GTC.data/VV-VH_ratio.img >> ${GTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${GTC_TMP}/GTC.data/Gamma0_VV_db.img --outfile=${GTC_TMP}/Gamma0.db.clean.tif --calc="A*(A>=-30)" --co="BIGTIFF=YES"
        gdal_trace_outline ${GTC_TMP}/Gamma0.db.clean.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${GTC_TMP}/valid.shp >> ${GTC_LOG}/log_output 2>&1

        # create intersect of image extent and AOI
        ogr2ogr -F "ESRI Shapefile" ${GTC_TMP}/extent_buf.shp ${GTC_TMP}/valid.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.001) from valid"
        EXTENT="${GTC_TMP}/extent_buf.shp"
        CROPLINE=${GTC_TMP}/cropline.shp

        if [[ -e ${GTC_AOI} ]];then
          intersect_shp ${EXTENT} ${GTC_AOI} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          CROPLINE=${EXTENT}
        fi

        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "COMPRESS=LZW" -co "BIGTIFF=YES" ${GTC_TMP}/rgb.vrt ${GTC_TMP}/GTC_final.tif >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        rm -rf ${GTC_TMP}/GTC.d* ${GTC_TMP}/rgb.vrt

        SECONDS=0
        echo -ne " Mask out layover/shadow areas ..." &&
        gdal_edit.py -a_nodata 0 ${GTC_OUT}.LS_mask.data/layover_shadow_mask_VH.img
        gdal_fillnodata.py -md 3 ${GTC_OUT}.LS_mask.data/layover_shadow_mask_VH.img ${GTC_TMP}/LS.map.max.nd.closed.tif >> ${GTC_LOG}/log_output 2>&1
        rm -rf ${GTC_OUT}.LS_mask.d*
        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "BIGTIFF=YES" ${GTC_TMP}/LS.map.max.nd.closed.tif ${GTC_TMP}/LS.map.tif >> ${GTC_LOG}/log_output 2>&1
        gdal_edit.py -unsetnodata ${GTC_TMP}/LS.map.tif # >> ${GTC_LOG}/log_mt_stacking 2>&1
        gdal_calc.py --overwrite --type='Byte' -A ${GTC_TMP}/LS.map.tif --outfile=${GTC_OUT}.LS.map.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES"  >> ${GTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${GTC_OUT}.LS.map.tif -B ${GTC_TMP}/GTC_final.tif --allBands=B --outfile=${GTC_OUT}.GTC.tif --calc="A*B" --NoDataValue=0 --co='COMPRESS=LZW'  --co="BIGTIFF=YES" >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        SECONDS=0
        echo -ne " Create a kmz file for Google Earth Visualization ..." &&
        gdal_contrast_stretch -ndv 0 -percentile-range 0.02 0.98 ${GTC_OUT}.GTC.tif ${GTC_TMP}/GTC.8bit.tif >> ${GTC_LOG}/log_output 2>&1
        gdal_translate -of KMLSUPEROVERLAY ${GTC_TMP}/GTC.8bit.tif ${GTC_OUT}.GTC.kmz -co format=JPEG >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

      elif [[ ${GTC_MODE} == 1 ]];then #neither db nor ratio calculation

          SECONDS=0
          echo -ne " Applying the geometric terrain correction ..." &&
          bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_SDV_10_TC.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_OUT}.GTC > ${GTC_LOG}/log_tc 2>&1
          duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
          [ $? -ne 0 ] && return ${ERR_TC}
          rm -rf ${GTC_TMP}/TF.d*

      fi

    else # SSV 10m case

      if [[ ${GTC_MODE} == 0 ]];then

        SECONDS=0
        echo -ne " Applying the geometric terrain correction and transform backscatter to decibel scale  ..." &&
        bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_SSV_10_TC_DB.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_TMP}/GTC > ${GTC_LOG}/log_tc_db 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${GTC_TMP}/TF.d*

        SECONDS=0
        echo -ne " Creating final output file ..." &&
        gdal_calc.py --overwrite -A ${GTC_TMP}/GTC.data/Gamma0_VV_db.img --outfile=${GTC_TMP}/Gamma0.db.clean.tif --calc="A*(A>=-30)" --co="BIGTIFF=YES"
        gdal_trace_outline ${GTC_TMP}/Gamma0.db.clean.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${GTC_TMP}/valid.shp >> ${GTC_LOG}/log_output 2>&1

        # create intersect of image extent and AOI
        ogr2ogr -F "ESRI Shapefile" ${GTC_TMP}/extent_buf.shp ${GTC_TMP}/valid.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.001) from valid"
        EXTENT=${GTC_TMP}/extent_buf.shp
        CROPLINE=${GTC_TMP}/cropline.shp

        if [[ -e ${GTC_AOI} ]];then
          intersect_shp ${EXTENT} ${GTC_AOI} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          CROPLINE=${EXTENT}
        fi

        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "COMPRESS=LZW" -co "BIGTIFF=YES"  ${GTC_TMP}/GTC.data/Gamma0_VV_db.img ${GTC_TMP}/GTC_final.tif >> ${GTC_LOG}/log_output 2>&1 >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        rm -rf ${GTC_TMP}/GTC.d*

        SECONDS=0
        echo -ne " Mask out layover/shadow areas ..." &&
        gdal_edit.py -a_nodata 0 ${GTC_OUT}.LS_mask.data/layover_shadow_mask_VV.img
        gdal_fillnodata.py -md 3 ${GTC_OUT}.LS_mask.data/layover_shadow_mask_VV.img ${GTC_TMP}/LS.map.max.nd.closed.tif >> ${GTC_LOG}/log_output 2>&1
        rm -rf ${GTC_OUT}.LS_mask.d*
        gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline -co "BIGTIFF=YES" ${GTC_TMP}/LS.map.max.nd.closed.tif ${GTC_TMP}/LS.map.tif >> ${GTC_LOG}/log_output 2>&1

        gdal_edit.py -unsetnodata ${GTC_TMP}/LS.map.tif # >> ${GTC_LOG}/log_mt_stacking 2>&1
        gdal_calc.py --overwrite --type='Byte' -A ${GTC_TMP}/LS.map.tif --outfile=${GTC_OUT}.LS.map.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES" >> ${GTC_LOG}/log_output 2>&1
        gdal_calc.py --overwrite -A ${GTC_OUT}.LS.map.tif -B ${GTC_TMP}/GTC_final.tif --allBands=B --outfile=${GTC_OUT}.GTC.tif --calc="A*B" --NoDataValue=0 --co='COMPRESS=LZW' --co="BIGTIFF=YES" >> ${GTC_LOG}/log_output 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        SECONDS=0
        echo -ne " Create a kmz file for Google Earth Visualization ..." &&
        gdal_contrast_stretch -ndv 0 -percentile-range 0.02 0.98 ${GTC_OUT}.GTC.tif ${GTC_TMP}/GTC.8bit.tif >> ${GTC_LOG}/log_kmz 2>&1
        gdal_translate -of KMLSUPEROVERLAY ${GTC_TMP}/GTC.8bit.tif ${GTC_OUT}.GTC.kmz -co format=JPEG >> ${GTC_LOG}/log_kmz 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
      else


        SECONDS=0
        echo -ne " Applying the geometric terrain correction ..." &&
        bash ${SNAP_EXE} ${S1_GRD2GTC_GRAPHS}/S1_GRD2GTC_SSV_10_TC.xml -x -q ${NR_OF_CPUS} -Pinput=${GTC_TMP}/TF.dim -Poutput=${GTC_OUT}.GTC > ${GTC_LOG}/log_tc 2>&1
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
        [ $? -ne 0 ] && return ${ERR_TC}
        rm -rf ${GTC_TMP}/TF.d*

      fi

    fi
  fi

  echo "------------------------------------------------------------------------------------------------------"
  echo " Info: Succesfully processed file: `basename ${GTC_IN}` to a geometrically terrain corrected product. "
  echo "------------------------------------------------------------------------------------------------------"
  echo ""

}


function s1_timeseries() {
  if [ -z "$8" ]; then
    echo " Missing arguments. Syntax:"
    echo " s1_timeseries <file_list> <AOI> <output directory> <datatype> <pol mode> <ls_map> <tmpdir> <logfile>"
    return
  fi

  # source other helpers
  source ${OPENSARKIT}/lib/helpers_source
  FILELIST=$1
  AOI_MT=$2
  OUT_STACK_MT=$3
  ODATATYPE=$4
  POL_MODE_MT=$5
  LS_MAP_OPT=$6
  TMP_MT=$7
  LOG_MT=$8

  # double amoun tof CPUs for SNAP related tasks
  NR_OF_CPUS=`echo "$(nproc) * 2" | bc`
  # actual amount of CPUs for Thumbnail creation
  CPUS=$(nproc)
  # error codes
  ERR_STACKING=" Error during stacking of multi-temporal images"
  ERR_SPECKLE=" Error during stacking of multi-temporal images"

  SECONDS=0
  echo -ne " Creating the multitemporal stack ..." &&
  bash ${SNAP_EXE} ${S1_RTC2TS_GRAPHS}/S1_RTC2TS_Stacking.xml -x -q ${NR_OF_CPUS} -Pfilelist=$1 -Poutput=${TMP_MT}/mt_stack.coreg.dim  >> ${LOG_MT}/log_mt_stacking 2>&1
  duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
  [ $? -ne 0 ] && return ${ERR_STACKING}

  SECONDS=0
  echo -ne " Executing multi-temporal Speckle-filtering to the VV polarized channels of the multi-temporal stack ... " &&
  bash $SNAP_EXE ${S1_RTC2TS_GRAPHS}/S1_RTC2TS_MT_Speckle.xml -x -q ${NR_OF_CPUS} -Pinput=${TMP_MT}/mt_stack.coreg.dim -Ppol=VV -Pthreshold=5 -Poutput=${TMP_MT}/mt_stack.vv.speckle.dim >> ${LOG_MT}/log_mt_stacking 2>&1
  duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
  [ $? -ne 0 ] && return ${ERR_SPECKLE}

  if [ ${POL_MODE_MT} == VV ];then
    rm -rf ${TMP_MT}/mt_stack.coreg.d*
  fi

  for MTs in `ls -1 ${TMP_MT}/mt_stack.vv.speckle.data/*img`;do
    basename ${MTs} | rev | cut -c 5- | rev >> ${TMP_MT}/tmp_list
  done
  BANDLIST=$(cat ${TMP_MT}/tmp_list | tr '\n' ',' | rev | cut -c 2- | rev)
  rm -f ${TMP_MT}/tmp_list

  SECONDS=0
  echo -ne " Converting linear to db-scale ... " &&
  bash $SNAP_EXE ${S1_RTC2TS_GRAPHS}/S1_RTC2TS_lin_to_db.xml -x -q ${NR_OF_CPUS} -Pinput=${TMP_MT}/mt_stack.vv.speckle.dim -Pbandlist=${BANDLIST} -Poutput=${TMP_MT}/mt_stack.vv.db.speckle.dim >> ${LOG_MT}/log_mt_stacking 2>&1
  duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
  [ $? -ne 0 ] && return ${ERR_SPECKLE}
  rm -rf ${TMP_MT}/mt_stack.vv.speckle.d*

  # change nodata value use (i.e. applies the nanmean etc. calculation in the next steps)
  sed -i 's|<NO_DATA_VALUE_USED>true</NO_DATA_VALUE_USED>|<NO_DATA_VALUE_USED>false</NO_DATA_VALUE_USED>|g' ${TMP_MT}/mt_stack.vv.db.speckle.dim

  SECONDS=0
  echo -ne " Create the minimum extent mask  ..." &&
  gdalbuildvrt -separate ${TMP_MT}/mask.vrt ${TMP_MT}/mt_stack.vv.db.speckle.data/*img >> ${LOG_MT}/log_mt_stacking 2>&1
  gdal_edit.py -unsetnodata ${TMP_MT}/mask.vrt >> ${LOG_MT}/log_mt_stacking 2>&1
  ost_mt_metrics.py -i ${TMP_MT}/mask.vrt -o ${TMP_MT}/mask -t 3 -p no -r no -m no >> ${LOG_MT}/log_mt_stacking 2>&1
  gdal_calc.py --overwrite -A ${TMP_MT}/mask.max.tif -B ${TMP_MT}/mask.min.tif --calc="(A*B)/(A*B)" --outfile ${TMP_MT}/mask.final.tif >> ${LOG_MT}/log_mt_stacking 2>&1
  gdal_trace_outline ${TMP_MT}/mask.final.tif -ndv 0 -no-donuts -out-cs ll -ogr-out ${TMP_MT}/extent.shp >> ${LOG_MT}/log_mt_stacking 2>&1
  duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

  # create output folders.
  #mkdir -p ${OUT_STACK_MT}/Timescan
  rm -rf ${OUT_STACK_MT}/Timeseries
  mkdir -p ${OUT_STACK_MT}/Timeseries/Thumbnails

  # create intersect of image extent and AOI
  ogr2ogr -F "ESRI Shapefile" ${TMP_MT}/extent_buf.shp ${TMP_MT}/extent.shp -dialect sqlite -sql "SELECT ST_buffer(geometry, -0.002) from extent "
  EXTENT="${TMP_MT}/extent_buf.shp"
  CROPLINE=${OUT_STACK_MT}/cropline.shp

  if [[ -e ${AOI_MT} ]];then
    intersect_shp ${EXTENT} ${AOI_MT} ${CROPLINE} >> ${LOG_MT}/log_mt_stacking 2>&1
  else
    CROPLINE=${EXTENT}
  fi

  if [[ $(echo ${FILELIST} | grep ".RTC.dim" | wc -l) -gt 0 ]];then
    SECONDS=0
    echo -ne " Creating the final layover shadow mask ..." &&
    if [ ${POL_MODE_MT} == VV ];then
      gdalbuildvrt -separate -srcnodata 0 ${TMP_MT}/ls_mask_stack.vrt $(echo ${FILELIST} | tr ',' ' ' | sed 's/.RTC.dim/.LS_mask.data\/layover_shadow_mask_VV.img/g') >> ${LOG_MT}/log_mt_stacking 2>&1
    else
      gdalbuildvrt -separate -srcnodata 0 ${TMP_MT}/ls_mask_stack.vrt $(echo ${FILELIST} | tr ',' ' ' | sed 's/.RTC.dim/.LS_mask.data\/layover_shadow_mask_VH.img/g') >> ${LOG_MT}/log_mt_stacking 2>&1
    fi
  else
    SECONDS=0
    echo -ne " Creating the final layover shadow mask ..." &&
    if [ ${POL_MODE_MT} == VV ];then
      gdalbuildvrt -separate -srcnodata 0 ${TMP_MT}/ls_mask_stack.vrt $(echo ${FILELIST} | tr ',' ' ' | sed 's/.GTC.dim/.LS_mask.data\/layover_shadow_mask_VV.img/g') >> ${LOG_MT}/log_mt_stacking 2>&1
    else
      gdalbuildvrt -separate -srcnodata 0 ${TMP_MT}/ls_mask_stack.vrt $(echo ${FILELIST} | tr ',' ' ' | sed 's/.GTC.dim/.LS_mask.data\/layover_shadow_mask_VH.img/g') >> ${LOG_MT}/log_mt_stacking 2>&1
    fi
  fi

  ost_mt_metrics.py -i ${TMP_MT}/ls_mask_stack.vrt -o ${TMP_MT}/LS.map -t 4 -p no -r no -m no >> ${LOG_MT}/log_mt_stacking 2>&1
  gdal_edit.py -a_nodata 0 ${TMP_MT}/LS.map.max.tif >> ${LOG_MT}/log_mt_stacking 2>&1
  gdal_fillnodata.py -md 3 ${TMP_MT}/LS.map.max.tif ${TMP_MT}/LS.map.tif >> ${LOG_MT}/log_mt_stacking 2>&1
  gdal_edit.py -unsetnodata ${TMP_MT}/LS.map.tif >> ${LOG_MT}/log_mt_stacking 2>&1
  gdal_calc.py --overwrite --type='Byte' -A ${TMP_MT}/LS.map.tif --outfile=${TMP_MT}/LS.map.invert.tif --calc="1*(A==0)" --NoDataValue=0 --co='COMPRESS=LZW' >> ${LOG_MT}/log_mt_stacking 2>&1
  gdalwarp -overwrite -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline ${TMP_MT}/LS.map.invert.tif ${OUT_STACK_MT}/LS.map.tif >> ${LOG_MT}/log_mt_stacking 2>&1
  rm -f ${TMP_MT}/LS.map*
  duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

  # create a list with sorted dates fro timeseries creation
  for file in $(ls -1 ${TMP_MT}/mt_stack.vv.db.speckle.data/*img); do

      DATE=`basename $(echo $file) | awk -F "_" '{print $4}'`
      date -d ${DATE} +%Y%m%d >> ${TMP_MT}/tmp.date
      echo $file >> ${TMP_MT}/tmp.filename

  done

  paste ${TMP_MT}/tmp.date ${TMP_MT}/tmp.filename >> ${TMP_MT}/tmp.date.filename
  sort -g ${TMP_MT}/tmp.date.filename >> ${TMP_MT}/tmp.date.filename.sorted

  i=1
  while read line; do

      DATE=$(echo $line | awk '{print $1}')
      file=$(echo $line | awk '{print $2}')

    if [ ${ODATATYPE} = "UInt16" ]; then

      SECONDS=0
      echo -ne " Scaling ${DATE} layer to 16 bit (-30 dB to 5dB) ..."
      gdal_translate -ot "UInt16" -projwin $(ogr_extent ${CROPLINE}) -scale -30 5 1 65536 ${file} ${TMP_MT}/${DATE}.16bit.tif >> ${LOG_MT}/log_mt_stacking 2>&1

      # replace all zeros to one to avoid outlier removal from rescaling
      ost_replace_values.py -i ${TMP_MT}/${DATE}.16bit.tif -o ${TMP_MT}/${DATE}.16bit.ones.tif -r 0 -n 1 >> ${LOG_MT}/log_mt_stacking 2>&1
      rm -f ${TMP_MT}/${DATE}.16bit.tif

      # cut to the actual extent of interest coming from the intersect above
      gdalwarp -overwrite -co "COMPRESS=LZW" -dstnodata "0" -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline ${TMP_MT}/${DATE}.16bit.ones.tif ${TMP_MT}/${i}_${DATE}.VV.16bit.tif >> ${LOG_MT}/log_mt_stacking 2>&1

      if [ ${LS_MAP_OPT} = 1 ];then
        gdal_calc.py --overwrite -A ${TMP_MT}/${i}_${DATE}.VV.16bit.tif -B ${OUT_STACK_MT}/LS.map.tif --calc="A*B" --outfile=${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.16bit.tif --NoDataValue=0 --co='COMPRESS=LZW' >> ${LOG_MT}/log_mt_stacking 2>&1
      else
        mv ${TMP_MT}/${i}_${DATE}.VV.16bit.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.16bit.tif
      fi

      rm -f ${TMP_MT}/${DATE}.VV.16.bit.ones.tif ${TMP_MT}/${i}_${DATE}.VV.16bit.tif
      echo ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.16bit.tif >> ${TMP_MT}/ts_vrt_list.txt
      duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
      rm -f ${TMP_MT}/${DATE}.16bit.ones.tif

      if [ ${POL_MODE_MT} == VV ];then

        if [ ! -z ${SEPAL} ];then
          echo "source ${OPENSARKIT}/lib/helpers_source; s1_create_thumb_vv ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.16bit.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${TMP_MT}; s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.VV.TN.jpg" >> ${TMP_MT}/tn_proc
        else
          s1_create_thumb_vv ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.16bit.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${TMP_MT} >> ${LOG_MT}/log_mt_stacking 2>&1
          s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.VV.TN.jpg >> ${LOG_MT}/log_mt_stacking 2>&1
        fi
      fi

    elif [ ${ODATATYPE} = "UInt8" ]; then

      SECONDS=0
      echo -ne " Scaling ${DATE} layer to 8 bit (-30 dB to 5dB) ..."
      gdal_translate -ot "Byte" -projwin $(ogr_extent ${CROPLINE}) -scale -30 5 1 255 ${file} ${TMP_MT}/${DATE}.8bit.tif >> ${LOG_MT}/log_mt_stacking 2>&1
      rm -f ${TMP_MT}/mt-metrics_ssv.data/Gamma0_VV.img ${TMP_MT}/mt-metrics_ssv.data/Gamma0_VV.hdr

      # replace all zeros to one to avoid outlier removal from rescaling
      ost_replace_values.py -i ${TMP_MT}/${DATE}.8bit.tif -o ${TMP_MT}/${DATE}.8bit.ones.tif -r 0 -n 1 >> ${LOG_MT}/log_mt_stacking 2>&1
      rm -f ${TMP_MT}/${DATE}.8bit.tif

      # cut to the actual extent of interest coming from the intersect above
      gdalwarp -overwrite -co "COMPRESS=LZW" -dstnodata "0" -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline ${TMP_MT}/${DATE}.8bit.ones.tif ${TMP_MT}//${i}_${DATE}.VV.8bit.tif >> ${LOG_MT}/log_mt_stacking 2>&1
      if [ ${LS_MAP_OPT} = 1 ];then
        gdal_calc.py --overwrite -A ${TMP_MT}/${i}_${DATE}.VV.8bit.tif -B ${OUT_STACK_MT}/LS.map.tif --calc="A*B" --outfile=${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.8bit.tif --NoDataValue=0 --co='COMPRESS=LZW' >> ${LOG_MT}/log_mt_stacking 2>&1
      else
        mv ${TMP_MT}/${i}_${DATE}.VV.8bit.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.8bit.tif
      fi
      rm -f ${TMP_MT}/${DATE}.VV.8bit.ones.tif ${TMP_MT}/${i}_${DATE}.VV.8bit.tif
      # create a list of files fo later vrt creation
      echo ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.8bit.tif >> ${TMP_MT}/ts_vrt_list.txt
      duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
      rm -f ${TMP_MT}/${DATE}.8bit.ones.tif

      if [ ${POL_MODE_MT} == VV ];then
        # if we are on sepal prepare for gnu parallel
        if [ ! -z ${SEPAL} ];then
          echo "source ${OPENSARKIT}/lib/helpers_source; s1_create_thumb_vv ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.8bit.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${TMP_MT}; s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.VV.TN.jpg" >> ${TMP_MT}/tn_proc
        else
          s1_create_thumb_vv ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.8bit.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${TMP_MT} >> ${LOG_MT}/log_mt_stacking 2>&1
          s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.VV.TN.jpg >> ${LOG_MT}/log_mt_stacking 2>&1
        fi
      fi

    elif [ ${ODATATYPE} = "Float32" ]; then

      SECONDS=0
      echo -ne " Cropping ${DATE} to common extent and cut by AOI ..."
      gdalwarp -overwrite -co "COMPRESS=LZW" -dstnodata "0" -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline ${file} ${TMP_MT}/${i}_${DATE}.VV.tif >> ${LOG_MT}/log_mt_stacking 2>&1
      if [ ${LS_MAP_OPT} = 1 ];then
        gdal_calc.py --overwrite -A ${TMP_MT}/${i}_${DATE}.VV.tif -B ${OUT_STACK_MT}/LS.map.tif --calc="A*B" --outfile=${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.tif --NoDataValue=0 --co='COMPRESS=LZW' >> ${LOG_MT}/log_mt_stacking 2>&1
      else
        mv ${TMP_MT}/${i}_${DATE}.VV.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.tif
      fi
      rm -f ${TMP_MT}/${i}_${DATE}.VV.tif
      echo ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.tif >> ${TMP_MT}/ts_vrt_list.txt
      duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

      if [ ${POL_MODE_MT} == VV ];then

        # if we are on sepal prepare for gnu parallel
        if [ ! -z ${SEPAL} ];then
          echo "source ${OPENSARKIT}/lib/helpers_source; s1_create_thumb_vv ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${TMP_MT}; s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.VV.TN.jpg" >> ${TMP_MT}/tn_proc
        else
          s1_create_thumb_vv ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${TMP_MT} >> ${LOG_MT}/log_mt_stacking 2>&1
          s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.VV.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.VV.TN.jpg >> ${LOG_MT}/log_mt_stacking 2>&1
        fi
      fi
    fi

    i=$(expr $i + 1)
  done < ${TMP_MT}/tmp.date.filename.sorted

  # removing original snap files
  rm -rf ${TMP_MT}/tmp*  ${TMP_MT}/mt_stack.vv.db.speckle.d*

  # create a virtual raster
  gdalbuildvrt -separate -srcnodata 0 ${OUT_STACK_MT}/Timeseries/timeseries.VV.vrt $(cat ${TMP_MT}/ts_vrt_list.txt | tr "\n" " ")  >> ${LOG_MT}/log_mt_stacking 2>&1
  rm -f ${TMP_MT}/ts_vrt_list.txt

  if [ ${POL_MODE_MT} == VV ];then

    echo -ne " Creating a gif animation file for the time-series stack ..."
    # using gnu parallel for production of TN and jpgs in case we are on Sepal
    if [ ! -z ${SEPAL} ];then
      cat ${TMP_MT}/tn_proc | parallel -j ${CPUS} bash -c {} >> ${LOG_MT}/log_mt_stacking 2>&1
    fi

    # Create a time-series animation
    REC_DIR=${PWD}
    cd ${TMP_MT}
    convert -delay 100 -loop 10 $(ls -1 *.VV.TN.jpg | sort -n) ${OUT_STACK_MT}/Timeseries/time_animation.gif  >> ${LOG_MT}/log_mt_stacking 2>&1
    cd ${REC_DIR}
    rm -f ${TMP_MT}/*.VV.TN.jpg

  fi

  if [ ${POL_MODE_MT} == VH ];then

    SECONDS=0
    echo -ne " Applying the multi-temporal speckle filter to the VH polarized channels of the multi-temporal stack ... " &&
    bash $SNAP_EXE ${S1_RTC2TS_GRAPHS}/S1_RTC2TS_MT_Speckle.xml -x -q ${NR_OF_CPUS} -Pinput=${TMP_MT}/mt_stack.coreg.dim -Ppol=VH -Pthreshold=5 -Poutput=${TMP_MT}/mt_stack.vh.speckle.dim >> ${LOG_MT}/log_mt_stacking 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_SPECKLE}
    rm -rf ${TMP_MT}/mt_stack.coreg.d*

    # create a bandlist for the conversion to db-scale
    for MTs in `ls -1 ${TMP_MT}/mt_stack.vh.speckle.data/*img`;do
      basename ${MTs} | rev | cut -c 5- | rev >> ${TMP_MT}/tmp_list
    done

    BANDLIST=$(cat ${TMP_MT}/tmp_list | tr '\n' ',' | rev | cut -c 2- | rev)
    rm -f ${TMP_MT}/tmp_list

    SECONDS=0
    echo -ne " Converting linear ot dB scale ... " &&
    bash $SNAP_EXE ${S1_RTC2TS_GRAPHS}/S1_RTC2TS_lin_to_db.xml -x -q ${NR_OF_CPUS} -Pinput=${TMP_MT}/mt_stack.vh.speckle.dim -Pbandlist=${BANDLIST} -Poutput=${TMP_MT}/mt_stack.vh.db.speckle.dim >> ${LOG_MT}/log_mt_stacking 2>&1
    duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"
    [ $? -ne 0 ] && return ${ERR_SPECKLE}
    rm -rf ${TMP_MT}/mt_stack.vh.speckle.d*

    # create a list for the timeseries, sorted by date
    for file in $(ls -1 ${TMP_MT}/mt_stack.vh.db.speckle.data/*img); do

        DATE=`basename $(echo $file) | awk -F "_" '{print $4}'`
        date -d ${DATE} +%Y%m%d >> ${TMP_MT}/tmp.date
        echo $file >> ${TMP_MT}/tmp.filename

    done

    paste ${TMP_MT}/tmp.date ${TMP_MT}/tmp.filename >> ${TMP_MT}/tmp.date.filename
    sort -g ${TMP_MT}/tmp.date.filename >> ${TMP_MT}/tmp.date.filename.sorted

    i=1
    while read line; do

      DATE=$(echo $line | awk '{print $1}')
      file=$(echo $line | awk '{print $2}')

      if [ ${ODATATYPE} = "UInt16" ]; then

        SECONDS=0
        echo -ne " Scaling ${DATE} layer to 16 bit (-25 dB to 5dB) ..."
        gdal_translate -ot "UInt16" -projwin $(ogr_extent ${CROPLINE}) -scale -25 5 1 65536 ${file} ${TMP_MT}/${DATE}.VH.16bit.tif >> ${LOG_MT}/log_mt_stacking 2>&1

        # replace all zeros to one to avoid outlier removal from rescaling
        ost_replace_values.py -i ${TMP_MT}/${DATE}.VH.16bit.tif -o ${TMP_MT}/${DATE}.VH.16bit.ones.tif -r 0 -n 1 >> ${LOG_MT}/log_mt_stacking 2>&1
        rm -f ${TMP_MT}/${DATE}.VH.16bit.tif

        # cut to the actual extent of interest coming from the intersect above
        gdalwarp -overwrite -co "COMPRESS=LZW" -dstnodata "0" -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline ${TMP_MT}/${DATE}.VH.16bit.ones.tif ${TMP_MT}/${i}_${DATE}.VH.16bit.tif >> ${LOG_MT}/log_mt_stacking 2>&1
        if [ ${LS_MAP_OPT} = 1 ];then
          gdal_calc.py --overwrite -A ${TMP_MT}/${i}_${DATE}.VH.16bit.tif -B ${OUT_STACK_MT}/LS.map.tif --calc="A*B" --outfile=${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.16bit.tif --NoDataValue=0 --co='COMPRESS=LZW' >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          mv ${TMP_MT}/${i}_${DATE}.VH.16bit.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.16bit.tif
        fi
        rm -f ${TMP_MT}/${DATE}.VH.16bit.ones.tif ${TMP_MT}/${i}_${DATE}.VH.16bit.tif
        echo ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.16bit.tif >> ${TMP_MT}/ts_vrt_list.VH.txt
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        echo -ne " Creating a thumbnail file for the acquisition of ${DATE} ..."
        # if we are on sepal prepare for gnu parallel
        if [ ! -z ${SEPAL} ];then
          echo "source ${OPENSARKIT}/lib/helpers_source; s1_create_thumb_rgb ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.16bit.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.16bit.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${TMP_MT}; s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.RGB.TN.jpg" >> ${TMP_MT}/tn_proc
        else
          # create a processing file for gnu parallel
          s1_create_thumb_rgb ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.16bit.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.16bit.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${TMP_MT} >> ${LOG_MT}/log_mt_stacking 2>&1
          s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.RGB.TN.jpg >> ${LOG_MT}/log_mt_stacking 2>&1
        fi

      elif [ ${ODATATYPE} = "UInt8" ]; then

        SECONDS=0
        echo -ne " Scaling ${DATE} layer to 8 bit (-25 dB to 5dB) ..."
        gdal_translate -ot "Byte" -projwin $(ogr_extent ${CROPLINE}) -scale -25 5 1 255 ${file} ${TMP_MT}/${DATE}.VH.8bit.tif >> ${LOG_MT}/log_mt_stacking 2>&1

        # replace all zeros to one to avoid outlier removal from rescaling
        ost_replace_values.py -i ${TMP_MT}/${DATE}.VH.8bit.tif -o ${TMP_MT}/${DATE}.VH.8bit.ones.tif -r 0 -n 1 >> ${LOG_MT}/log_mt_stacking 2>&1
        rm -f ${TMP_MT}/${DATE}.VH.8bit.tif

        # cut to the actual extent of interest coming from the intersect above
        gdalwarp -overwrite -co "COMPRESS=LZW" -dstnodata "0" -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline ${TMP_MT}/${DATE}.VH.8bit.ones.tif ${TMP_MT}/${i}_${DATE}.VH.8bit.tif >> ${LOG_MT}/log_mt_stacking 2>&1
        if [ ${LS_MAP_OPT} = 1 ];then
          gdal_calc.py --overwrite -A ${TMP_MT}/${i}_${DATE}.VH.8bit.tif -B ${OUT_STACK_MT}/LS.map.tif --calc="A*B" --outfile=${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.8bit.tif --NoDataValue=0 --co='COMPRESS=LZW' >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          mv ${TMP_MT}/${i}_${DATE}.VH.8bit.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.8bit.tif
        fi
        rm -f ${TMP_MT}/${DATE}.VH.8bit.ones.tif ${TMP_MT}/${i}_${DATE}.VH.8bit.tif
        echo ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.8bit.tif >> ${TMP_MT}/ts_vrt_list.VH.txt
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        # if we are on sepal prepare for gnu parallel
        if [ ! -z ${SEPAL} ];then
          echo "source ${OPENSARKIT}/lib/helpers_source; s1_create_thumb_rgb ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.8bit.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.8bit.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${TMP_MT}; s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.RGB.TN.jpg" >> ${TMP_MT}/tn_proc
        else
          # create a processing file for gnu parallel
          s1_create_thumb_rgb ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.8bit.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.8bit.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${TMP_MT} >> ${LOG_MT}/log_mt_stacking 2>&1
          s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.RGB.TN.jpg >> ${LOG_MT}/log_mt_stacking 2>&1
        fi

      elif [ ${ODATATYPE} = "Float32" ]; then

        SECONDS=0
        echo -ne " Cropping ${DATE} to common extent and cut by AOI ..."
        gdalwarp -overwrite -co "COMPRESS=LZW" -dstnodata "0" -multi -wm "4096" -cutline ${CROPLINE} -crop_to_cutline ${file} ${TMP_MT}/${i}_${DATE}.VH.tif >> ${LOG_MT}/log_mt_stacking 2>&1
        if [ ${LS_MAP_OPT} = 1 ];then
          gdal_calc.py --overwrite -A ${TMP_MT}/${i}_${DATE}.VH.tif -B ${OUT_STACK_MT}/LS.map.tif --calc="A*B" --outfile=${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.tif --NoDataValue=0 --co='COMPRESS=LZW' >> ${LOG_MT}/log_mt_stacking 2>&1
        else
          mv ${TMP_MT}/${i}_${DATE}.VH.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.tif
        fi

        echo ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.tif >> ${TMP_MT}/ts_vrt_list.VH.txt
        duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

        # if we are on sepal prepare for gnu parallel
        if [ ! -z ${SEPAL} ];then
          echo "source ${OPENSARKIT}/lib/helpers_source; s1_create_thumb_rgb ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${TMP_MT}; s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.RGB.TN.jpg" >> ${TMP_MT}/tn_proc
        else
          # create a processing file for gnu parallel
          s1_create_thumb_rgb ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VV.tif ${OUT_STACK_MT}/Timeseries/${i}_${DATE}.VH.tif ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${TMP_MT} >> ${LOG_MT}/log_mt_stacking 2>&1
          s1_create_labeled_jpeg ${OUT_STACK_MT}/Timeseries/Thumbnails/${i}_${DATE}.RGB.TN.tif ${DATE} ${TMP_MT}/${i}_${DATE}.RGB.TN.jpg >> ${LOG_MT}/log_mt_stacking 2>&1
        fi
      fi

    i=$(expr $i + 1)
  done < ${TMP_MT}/tmp.date.filename.sorted

    # remvoing original snap files
    rm -rf ${TMP_MT}/mt_stack.vh.db.speckle.d*

    echo -ne " Creating a gif animation file for the time-series stack ..."
    # using gnu parallel for production of TN and jpgs in case we are on Sepal
    if [ ! -z ${SEPAL} ];then
      cat ${TMP_MT}/tn_proc | parallel -j ${CPUS} bash -c {} >> ${LOG_MT}/log_mt_stacking 2>&1
    fi

    # Create a time-series animation
    REC_DIR=${PWD}
    cd ${TMP_MT}
    convert -delay 100 -loop 10 $(ls -1 *.TN.jpg | sort -g) ${OUT_STACK_MT}/Timeseries/time_animation.gif  >> ${LOG_MT}/log_mt_stacking 2>&1
    cd ${REC_DIR}
    rm -f ${TMP_MT}/*.RGB.TN.jpg

    # create a virtual raster
    gdalbuildvrt -separate -srcnodata 0 ${OUT_STACK_MT}/Timeseries/timeseries.VH.vrt $(cat ${TMP_MT}/ts_vrt_list.VH.txt | tr "\n" " ")  >> ${LOG_MT}/log_mt_stacking 2>&1
    rm -f ${TMP_MT}/ts_vrt_list.txt

  fi

  echo "------------------------------------------------------------------------------------------------------"
  echo " Info: Succesfully created a stack of time-series. "
  echo "------------------------------------------------------------------------------------------------------"

}


function s1_timescan() {
  if [ -z "$7" ]; then
    echo " Missing arguments. Syntax:"
    echo " s1_timescan <inputfile> <output directory> <file prefix>"
    return
  fi

  # source other helpers
  source ${OPENSARKIT}/lib/helpers_source

  TS_STACK=$(readlink -f $1)
  OUT_DIR=$(readlink -f $2)
  PREFIX=$3

  mkdir -p ${OUT_DIR}

  SECONDS=0
  echo -ne " Calculating multi-temporal metrics for the VV polarization ..."
  ost_mt_metrics.py -i ${OUT_STACK_MT}/Timeseries/timeseries.VV.vrt -o ${OUT_DIR}/Gamma0.VV -t 1 -p yes -r yes -m yes >> ${LOG_MT}/log_mt_stacking 2>&1
  mv ${OUT_DIR}/Gamma0.VV.avg.tif ${OUT_DIR}/01_Gamma0.VV.avg.tif && gdal_edit.py -a_nodata 0 ${OUT_DIR}/01_Gamma0.VV.avg.tif
  mv ${OUT_DIR}/Gamma0.VV.max.tif ${OUT_DIR}/02_Gamma0.VV.max.tif && gdal_edit.py -a_nodata 0 ${OUT_DIR}/02_Gamma0.VV.max.tif
  mv ${OUT_DIR}/Gamma0.VV.min.tif ${OUT_DIR}/03_Gamma0.VV.min.tif && gdal_edit.py -a_nodata 0 ${OUT_DIR}/03_Gamma0.VV.min.tif
  mv ${OUT_DIR}/Gamma0.VV.std.tif ${OUT_DIR}/04_Gamma0.VV.std.tif && gdal_edit.py -a_nodata 0 ${OUT_DIR}/04_Gamma0.VV.std.tif
  mv ${OUT_DIR}/Gamma0.VV.cov.tif ${OUT_DIR}/05_Gamma0.VV.cov.tif && gdal_edit.py -a_nodata 0 ${OUT_DIR}/05_Gamma0.VV.cov.tif
  duration=$SECONDS && echo -e " done ($(($duration / 60)) minutes and $(($duration % 60)) seconds elapsed)"

}


function s1_create_thumb_vv() {

	if [ -z "$3" ]; then
	    echo " Missing arguments. Syntax:"
	    echo " s1_create_thumb_vv <input_VV> <outfile> <tmp-folder>"
	    return
  fi

  INPUT_VV=$(readlink -f $1)
  OUT_TN=$(readlink -f $2)
  TMP_TN=$(readlink -f $3)
  INPUT_VV_BASE=$(basename ${INPUT_VV})

  source ${OPENSARKIT}/lib/helpers_source
	echo -ne " Creating a thumbnail file for the acquisition of ${DATE} ..."
  # resize and  bring to 8 bit the VV channel
  gdal_translate -outsize 20% 20% -a_nodata 0 ${INPUT_VV} ${TMP_TN}/${INPUT_VV_BASE}
  gdal_contrast_stretch -ndv 0 -percentile-range 0.01 0.99 ${TMP_TN}/${INPUT_VV_BASE} ${OUT_TN}
  rm -f ${TMP_TN}/${i}_${DATE}.VV.TN.tif

}

function s1_create_thumb_rgb() {

	if [ -z "$4" ]; then
	    echo " Missing arguments. Syntax:"
	    echo " s1_create_thumb_rgb <input_VV> <input_VH> <outfile> <tmp-folder>"
	    return
  fi

  INPUT_VV=$(readlink -f $1)
  INPUT_VH=$(readlink -f $2)
  OUT_TN=$(readlink -f $3)
  TMP_TN=$(readlink -f $4)

  INPUT_VV_BASE=$(basename ${INPUT_VV})
  INPUT_VH_BASE=$(basename ${INPUT_VH})

  source ${OPENSARKIT}/lib/helpers_source
	echo -ne " Creating a thumbnail file for the acquisition of ${DATE} ..."
  # resize and  bring to 8 bit the VV channel
  gdal_translate -outsize 20% 20% -a_nodata 0 ${INPUT_VV} ${TMP_TN}/${INPUT_VV_BASE}
  gdal_contrast_stretch -ndv 0 -percentile-range 0.01 0.99 ${TMP_TN}/${INPUT_VV_BASE} ${TMP_TN}/${INPUT_VV_BASE}.8bit.tif
  rm -f ${TMP_TN}/${INPUT_VV_BASE}

  # resize and  bring to 8 bit the VH channel
  gdal_translate -outsize 20% 20% -a_nodata 0 ${INPUT_VH} ${TMP_TN}/${INPUT_VH_BASE}
  gdal_contrast_stretch -ndv 0 -percentile-range 0.01 0.99 ${TMP_TN}/${INPUT_VH_BASE} ${TMP_TN}/${INPUT_VH_BASE}.8bit.tif
  rm -f ${TMP_TN}/${INPUT_VH_BASE}

  # create ratio band in float and stretch to 8 bit
  gdal_calc.py --overwrite -A ${TMP_TN}/${INPUT_VV_BASE}.8bit.tif -B ${TMP_TN}/${INPUT_VH_BASE}.8bit.tif --calc="A/B" --type=Float32 --outfile=${TMP_TN}/${INPUT_VV_BASE}.VVVH.TN.tif
  gdal_contrast_stretch -ndv 0 -percentile-range 0.02 0.98 ${TMP_TN}/${INPUT_VV_BASE}.VVVH.TN.tif ${TMP_TN}/${INPUT_VV_BASE}.VVVH.TN.8bit.tif
  rm -f ${TMP_TN}/${INPUT_VV_BASE}.VVVH.TN.tif

  # create RGB Thumbnail
  gdal_merge.py -separate -co "COMPRESS=LZW" -a_nodata 0 -o ${OUT_TN} \
                      ${TMP_TN}/${INPUT_VV_BASE}.8bit.tif ${TMP_TN}/${INPUT_VH_BASE}.8bit.tif ${TMP_TN}/${INPUT_VV_BASE}.VVVH.TN.8bit.tif

}

function s1_create_labeled_jpeg() {

	if [ -z "$3" ]; then
	    echo " Missing arguments. Syntax:"
	    echo "  s1_create_labeled_jpeg <input> <label> <output.jpg>"
	    return
  fi

  # create JPEG for gif creation
  gdal_translate -of JPEG -a_nodata 0 $1 $3

  # add the acq date to jpeg
  WIDTH_TN=$(identify -format %w $3)
  HEIGHT_TN=$(identify -format %h $3)
  HEIGHT_LABEL=$(expr $HEIGHT_TN / 15)

  # add annotation with date
  convert -background '#0008' -fill white -gravity center -size ${WIDTH_TN}x${HEIGHT_LABEL} caption:"$2" \
         $3 +swap -gravity north -composite $3

}
