#! /bin/bash
# If not stated otherwise (i.e. taken from https://github.com/dwtkns/gdal-cheat-sheet)
# the MIT License applies

# The MIT License (MIT)
# Copyright (c) 2016 Andreas Vollrath

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is furnished
# to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
# OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

function gdal_size() {
# taken from https://github.com/dwtkns/gdal-cheat-sheet
#Size Functions
#This size function echos the pixel dimensions of a given file in the format expected by gdalwarp.
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_size <input_raster>"
        return
    fi
    SIZE=$(gdalinfo $1 |\
        grep 'Size is ' |\
        cut -d\   -f3-4 |\
        sed 's/,//g')
    echo -n "$SIZE"
}



function gdal_extent() {
# taken from https://github.com/dwtkns/gdal-cheat-sheet
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_extent <input_raster>"
        return
    fi
    EXTENT=$(gdalinfo $1 |\
        grep "Lower Left\|Upper Right" |\
        sed "s/Lower Left  //g;s/Upper Right //g;s/).*//g" |\
        tr "\n" " " |\
        sed 's/ *$//g' |\
        tr -d "[(,]")
    echo -n "$EXTENT"
}

function gdal_ul() {
# taken from https://github.com/dwtkns/gdal-cheat-sheet
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_extent <input_raster>"
        return
    fi
    EXTENT=$(gdalinfo $1 |\
        grep "Upper Left\|Lower Right" |\
        sed "s/Upper Left  //g;s/Lower Right //g;s/).*//g" |\
        tr "\n" " " |\
        sed 's/ *$//g' |\
        tr -d "[(,]")
    echo -n "$EXTENT"
}

function ogr_extent() {
# taken from https://github.com/dwtkns/gdal-cheat-sheet

#This can be used to easily resample one raster to the dimensions of another:
#gdalwarp -ts $(gdal_size bigraster.tif) -r cubicspline smallraster.tif resampled_smallraster.tif


# Extent Functions
# These extent functions echo the extent of the given file in the order/format expected by gdal_translate -projwin. (Originally from Linfiniti).
# Extents can be passed directly into a gdal_translate command like so:

# gdal_translate -projwin $(ogr_extent boundingbox.shp) input.tif clipped_output.tif
# or
# gdal_translate -projwin $(gdal_extent target_crop.tif) input.tif clipped_output.tif
# This can be a useful way to quickly crop one raster to the same extent as another.
# Add these to your ~/.bash_profile file for easy terminal access.
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  ogr_extent <input_vector>"
        return
    fi
    EXTENT=$(ogrinfo -al -so $1 |\
        grep Extent |\
        sed 's/Extent: //g' |\
        sed 's/(//g' |\
        sed 's/)//g' |\
        sed 's/ - /, /g')
    EXTENT=`echo $EXTENT | awk -F ',' '{print $1 " " $4 " " $3 " " $2}'`
    echo -n "$EXTENT"
}

function ogr_layer_extent() {
# taken from https://github.com/dwtkns/gdal-cheat-sheet
    if [ -z "$2" ]; then
        echo "Missing arguments. Syntax:"
        echo "  ogr_extent <input_vector> <layer_name>"
        return
    fi
    EXTENT=$(ogrinfo -so $1 $2 |\
        grep Extent |\
        sed 's/Extent: //g' |\
        sed 's/(//g' |\
        sed 's/)//g' |\
        sed 's/ - /, /g')
    EXTENT=`echo $EXTENT | awk -F ',' '{print $1 " " $4 " " $3 " " $2}'`
    echo -n "$EXTENT"
}

function gdal_max() {
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_max <input_raster>"
        return
    fi
    MAX=$(gdalinfo -stats $1 |\
	grep STATISTICS_MAXIMUM |\
        awk -F "=" $'{print $2}')
    echo -n "$MAX"
}

function gdal_min() {
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_min <input_raster>"
        return
    fi
    MIN=$(gdalinfo -stats $1 |\
	grep STATISTICS_MINIMUM |\
        awk -F "=" $'{print $2}')
    echo -n "$MIN"
}

function gdal_mean() {
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_mean <input_raster>"
        return
    fi
    MEAN=$(gdalinfo -stats $1 |\
	grep STATISTICS_MEAN |\
        awk -F "=" $'{print $2}')
    echo -n "$MEAN"
}

function gdal_stddev() {
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_stddev <input_raster>"
        return
    fi
    STDDEV=$(gdalinfo -stats $1 |\
	grep STATISTICS_STDDEV |\
        awk -F "=" $'{print $2}')
    echo -n "$STDDEV"
}

function gdal_format() {
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_format <input_raster>"
        return
    fi
    FORMAT=$(gdalinfo $1 |\
	     grep Driver |\
	     sed 's/Driver: //g' |\
             awk -F"/" $'{print $1}')
	echo -n "$FORMAT"
}

function gdal_nodata() {
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_nodata <input_raster>"
        return
    fi
    NODATA=$(gdalinfo $1 |\
             grep NoData |\
	     awk -F "=" '{print $2}')
	echo -n "$NODATA"
}

function gdal_EPSG() {
    if [ -z "$1" ]; then
        echo "Missing arguments. Syntax:"
        echo "  gdal_EPSG <input_raster>"
        return
    fi
    EPSG=$(gdalinfo $1 |\
           grep AUTHORITY |\
	   tail -1 |\
	   sed 's/    AUTHORITY\[\"EPSG\"\,\"//g' |\
	   sed 's/\"\]\]//')
	echo -n "$EPSG"
}


function gdal_datatype() {
  if [ -z "$1" ]; then
      echo "Missing arguments. Syntax:"
      echo "  gdal_datatype <input_raster>"
      return
  fi
  DTYPE=$(gdalinfo $1 |\
          grep Type |\
          awk '{print $4}' |\
          awk -F"=" '{print $2}' |\
          rev | cut -c 2- | rev)
          echo -n "$DTYPE"
}

function gdal_resolution() {
  if [ -z "$1" ]; then
      echo "Missing arguments. Syntax:"
      echo "  gdal_resolution <input_raster>"
      return
  fi
  RES=$(gdalinfo $1 |\
       grep "Pixel Size" |\
       sed -e 's/Pixel Size = (//g' |\
       sed 's/,/ /g' |\
       sed 's/)//g')
       echo -n "$RES"
}

function gdal_offset() {
  # intended for use with gdal_edit.py
  if [ -z "$3" ]; then
      echo "Missing arguments. Syntax:"
      echo " gdal_offset <input_raster> <x-offset> <y-offset>"
      return
  fi

  source ${OPENSARKIT}/lib/helpers_source
  RES=$(gdal_resolution $1 | awk '{print $1}')
  XMIN=$(gdal_extent $1 | awk '{print $1}')
  YMIN=$(gdal_extent $1 | awk '{print $2}')
  XMAX=$(gdal_extent $1 | awk '{print $3}')
  YMAX=$(gdal_extent $1 | awk '{print $4}')
  NEW_XMIN=$(echo ${RES}*$2 + ${XMIN} | bc -l)
  NEW_XMAX=$(echo ${RES}*$2 + ${XMAX} | bc -l)
  NEW_YMIN=$(echo ${RES}*$3 + ${YMIN} | bc -l)
  NEW_YMAX=$(echo ${RES}*$3 + ${YMAX} | bc -l)
  echo -n "${NEW_XMIN} ${NEW_YMAX} ${NEW_XMAX} ${NEW_YMIN} "
}

function intersect_shp() {

    if [ -z "$3" ]; then
        echo " Missing arguments. Syntax:"
        echo " intersect_shp <input_shape 1> <input_shape 2> <output_shape>"
        return
    fi

    ISHAPE1=$(readlink -f $1)
    ISHAPE2=$(readlink -f $2)
    OSHAPE=$(readlink -f $3)

    ILAYER1=$(ogrinfo ${ISHAPE1} | awk 'NR==3' | awk '{print $2}')
    ILAYER2=$(ogrinfo ${ISHAPE2} | awk 'NR==3' | awk '{print $2}')
    VRTDIR=$(dirname ${ISHAPE1})

    echo "<OGRVRTDataSource>" > ${VRTDIR}/.intersect.vrt
    echo "<OGRVRTLayer name=\"layer1\">" >> ${VRTDIR}/.intersect.vrt
    echo "<SrcDataSource>${ISHAPE1}</SrcDataSource>" >> ${VRTDIR}/.intersect.vrt
    echo "<SrcLayer>${ILAYER1}</SrcLayer>" >> ${VRTDIR}/.intersect.vrt
    echo "</OGRVRTLayer>" >> ${VRTDIR}/.intersect.vrt
    echo "<OGRVRTLayer name=\"layer2\">" >> ${VRTDIR}/.intersect.vrt
    echo "<SrcDataSource>${ISHAPE2}</SrcDataSource>" >> ${VRTDIR}/.intersect.vrt
    echo "<SrcLayer>${ILAYER2}</SrcLayer>" >> ${VRTDIR}/.intersect.vrt
    echo "</OGRVRTLayer>" >> ${VRTDIR}/.intersect.vrt
    echo "</OGRVRTDataSource>" >> ${VRTDIR}/.intersect.vrt

    ogr2ogr -f "ESRI Shapefile" ${OSHAPE} ${VRTDIR}/.intersect.vrt -dialect sqlite -sql "SELECT ST_Intersection(st_unaryunion(st_collect(a.geometry)), st_unaryunion(st_collect(b.geometry))) AS geometry FROM layer1 a, layer2 b" #>> ${VRTDIR}/.tmp_intersect 2>&1
    [ $? -ne 0 ] && echo " Intersection was not possible" && return 1
    rm -f ${VRTDIR}/.intersect.vrt
}

function st_intersects_shp() {

    if [ -z "$3" ]; then
        echo " Missing arguments. Syntax:"
        echo " intersect_shp <input_shape 1> <input_shape 2> <output_shape>"
        return
    fi

    ISHAPE1=$(readlink -f $1)
    ISHAPE2=$(readlink -f $2)
    OSHAPE=$(readlink -f $3)

    ILAYER1=$(ogrinfo ${ISHAPE1} | awk 'NR==3' | awk '{print $2}')
    ILAYER2=$(ogrinfo ${ISHAPE2} | awk 'NR==3' | awk '{print $2}')
    VRTDIR=$(dirname ${ISHAPE1})

    echo "<OGRVRTDataSource>" > ${VRTDIR}/.intersect.vrt
    echo "<OGRVRTLayer name=\"layer1\">" >> ${VRTDIR}/.intersect.vrt
    echo "<SrcDataSource>${ISHAPE1}</SrcDataSource>" >> ${VRTDIR}/.intersect.vrt
    echo "<SrcLayer>${ILAYER1}</SrcLayer>" >> ${VRTDIR}/.intersect.vrt
    echo "</OGRVRTLayer>" >> ${VRTDIR}/.intersect.vrt
    echo "<OGRVRTLayer name=\"layer2\">" >> ${VRTDIR}/.intersect.vrt
    echo "<SrcDataSource>${ISHAPE2}</SrcDataSource>" >> ${VRTDIR}/.intersect.vrt
    echo "<SrcLayer>${ILAYER2}</SrcLayer>" >> ${VRTDIR}/.intersect.vrt
    echo "</OGRVRTLayer>" >> ${VRTDIR}/.intersect.vrt
    echo "</OGRVRTDataSource>" >> ${VRTDIR}/.intersect.vrt


    ogr2ogr -f "ESRI Shapefile" ${OSHAPE} ${VRTDIR}/.intersect.vrt -dialect sqlite \
            -sql "SELECT *
                  FROM layer1 a, layer2 b
                  WHERE ST_Intersects(a.geometry, b.geometry)" >> ${VRTDIR}/.tmp_intersect 2>&1
    [ $? -ne 0 ] && echo " Intersection was not possible" && return 1
    rm -f ${VRTDIR}/.intersect.vrt
  }

function st_intersection_area() {

      if [ -z "$2" ]; then
          echo " Missing arguments. Syntax:"
          echo " st_intersects_area <input_shape 1> <input_shape 2>"
          return
      fi

      ISHAPE1=$(readlink -f $1)
      ISHAPE2=$(readlink -f $2)

      ILAYER1=$(ogrinfo ${ISHAPE1} | awk 'NR==3' | awk '{print $2}')
      ILAYER2=$(ogrinfo ${ISHAPE2} | awk 'NR==3' | awk '{print $2}')
      VRTDIR=$(dirname ${ISHAPE1})

      echo "<OGRVRTDataSource>" > ${VRTDIR}/.intersect.vrt
      echo "<OGRVRTLayer name=\"layer1\">" >> ${VRTDIR}/.intersect.vrt
      echo "<SrcDataSource>${ISHAPE1}</SrcDataSource>" >> ${VRTDIR}/.intersect.vrt
      echo "<SrcLayer>${ILAYER1}</SrcLayer>" >> ${VRTDIR}/.intersect.vrt
      echo "</OGRVRTLayer>" >> ${VRTDIR}/.intersect.vrt
      echo "<OGRVRTLayer name=\"layer2\">" >> ${VRTDIR}/.intersect.vrt
      echo "<SrcDataSource>${ISHAPE2}</SrcDataSource>" >> ${VRTDIR}/.intersect.vrt
      echo "<SrcLayer>${ILAYER2}</SrcLayer>" >> ${VRTDIR}/.intersect.vrt
      echo "</OGRVRTLayer>" >> ${VRTDIR}/.intersect.vrt
      echo "</OGRVRTDataSource>" >> ${VRTDIR}/.intersect.vrt

      ogrinfo -q ${VRTDIR}/.intersect.vrt -dialect sqlite -sql "SELECT Area(ST_Intersection(st_unaryunion(st_collect(a.geometry)), st_unaryunion(st_collect(b.geometry)))) FROM layer1 a, layer2 b" | awk -F '\=' '{print $2}'
      [ $? -ne 0 ] && echo " Intersection was not possible" && return 1
      rm -f ${VRTDIR}/.intersect.vrt
}


function check_overlap_aoi() {

	if [ -z "$3" ]; then
          echo " Missing arguments. Syntax:"
          echo " check_overlap_aoi <AOI> <OST inventory shape> <temp-folder>"
          return
      fi

	AOIFILE=$(readlink -f $1)
	SHAPE=$(readlink -f $2)
 	TMP_OVERLAP=$(readlink -f $3)
	BASE_SHAPE=$(basename ${SHAPE} | rev | cut -c 5- | rev)
	BASE_AOI=$(basename ${AOIFILE} | rev | cut -c 5- | rev)

	# create a list of tracks
	ogrinfo -q ${SHAPE} -sql "SELECT DISTINCT TRACK FROM \"${BASE_SHAPE}\"" | grep TRACK | awk -F '\=' '{print $2}' > ${TMP_DIR}/track_list

	# get intersect area
	cat ${TMP_DIR}/track_list | while read track; do

			if [[ ${track} != "" ]];then

				# create a dissolved version of the track from all acquisitions
				ogr2ogr -f "ESRI Shapefile" ${TMP_DIR}/${BASE_SHAPE}.${track}.shp ${SHAPE} -dialect sqlite -sql "SELECT ST_Buffer(st_unaryunion(st_collect(geometry)),-0.05) FROM \"${BASE_SHAPE}\"  WHERE \"TRACK\" = ${track}"

				# intersect dissolved track with AOI
				intersect_shp ${AOIFILE} ${TMP_DIR}/${BASE_SHAPE}.${track}.shp ${TMP_DIR}/${BASE_SHAPE}.${track}.inter.shp
				rm ${TMP_DIR}/${BASE_SHAPE}.${track}.shp ${TMP_DIR}/${BASE_SHAPE}.${track}.dbf ${TMP_DIR}/${BASE_SHAPE}.${track}.prj ${TMP_DIR}/${BASE_SHAPE}.${track}.shx

				# get area for intersected region
				AREA=`ogrinfo -q ${TMP_DIR}/${BASE_SHAPE}.${track}.inter.shp -dialect sqlite -sql "SELECT Area(geometry) FROM \"${BASE_SHAPE}.${track}.inter\"" | grep Area | awk -F '\=' '{print $2}'`
				rm ${TMP_DIR}/${BASE_SHAPE}.${track}*

				# create a list of dates
				ogrinfo -q ${SHAPE} -sql "SELECT DISTINCT DATE FROM \"${BASE_SHAPE}\" WHERE \"TRACK\" = ${track}" | grep DATE | awk -F '\=' '{print $2}' > ${TMP_DIR}/date_list

					# loop through dates
					cat ${TMP_DIR}/date_list | while read dates; do
						if [[ ${dates} != "" ]];then

							# create a dissolved version of the track/date
							ogr2ogr -f "ESRI Shapefile" ${TMP_DIR}/${BASE_SHAPE}.${track}.${dates}.shp ${SHAPE} -dialect sqlite -sql "SELECT st_unaryunion(st_collect(geometry)) FROM \"${BASE_SHAPE}\"  WHERE \"TRACK\" = ${track} AND \"DATE\" = ${dates}"

							# intersect rack with AOI
							intersect_shp ${AOIFILE} ${TMP_DIR}/${BASE_SHAPE}.${track}.${dates}.shp ${TMP_DIR}/${BASE_SHAPE}.${track}.${dates}.inter.shp
							rm ${TMP_DIR}/${BASE_SHAPE}.${track}.${dates}.sh* ${TMP_DIR}/${BASE_SHAPE}.${track}.${dates}.prj ${TMP_DIR}/${BASE_SHAPE}.${track}.${dates}.dbf

							# get area for intersected region
							AREA_DATE=`ogrinfo -q ${TMP_DIR}/${BASE_SHAPE}.${track}.${dates}.inter.shp -dialect sqlite -sql "SELECT Area(geometry) FROM \"${BASE_SHAPE}.${track}.${dates}.inter\"" | grep Area | awk -F '\=' '{print $2}'`

              if [ $track -eq 25 ];then
                echo $dates $AREA_DATE $AREA
              fi
							# check if area is greater than, and f not delete entries from inventory shapefile
							test=`echo "${AREA} >= ${AREA_DATE}" | bc -l`

							if [[ ${test} -eq 1 ]]; then

								# delete entries
								ogrinfo -q ${SHAPE} -dialect sqlite -sql "DELETE FROM \"${BASE_SHAPE}\" WHERE \"TRACK\" = ${track} AND \"DATE\" = ${dates}"

							fi

							rm ${TMP_DIR}/${BASE_SHAPE}.${track}.${dates}.*

						fi
					done
			fi
	done

	rm ${TMP_DIR}/date_list ${TMP_DIR}/track_list
}

function adjust_equator_tracks() { # should only applied to ascending tracks!

	if [ -z "$2" ]; then
					echo " Missing arguments. Syntax:"
					echo " adjust_equator_tracks <OST inventory shape> <temp-folder>"
					return
	fi

	TMP_INV_FILE=$(readlink -f $1)
	TMP_INV_BASE=$(basename ${TMP_INV_FILE} | rev | cut -c 5- | rev)
	TMP_DIR=$(readlink -f $2)

	# create a lst of dates
	ogrinfo -q ${TMP_INV_FILE} -sql "SELECT DISTINCT DATE FROM \"${TMP_INV_BASE}\" " | grep DATE | awk -F '\=' '{print $2}' > ${TMP_DIR}/date_list

	cat ${TMP_DIR}/date_list | while read date; do

		# get the number of tracks per acquisition date
		NR_OF_TRACKS=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT \"TRACK\" FROM \"${TMP_INV_BASE}\" WHERE \"DATE\" = ${date} " | grep Track | wc -l`

		# check if there are more than one track per acquistion date
		if [[ ${NR_OF_TRACKS} -ge 2 ]];then

			 for ((i=1;i<=${NR_OF_TRACKS};i++));do
        echo `ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT \"TRACK\" FROM \"${TMP_INV_BASE}\" WHERE \"DATE\" = ${date} " | grep Track | awk "NR == $i" | awk -F '\=' '{print $2}'` >> ${TMP_DIR}/${date}_list
			 done

      i=1
			cat ${TMP_DIR}/${date}_list | sort | while read line; do

        i=`expr $i + 1`

        j=`cat ${TMP_DIR}/${date}_list | sort | awk "NR == $i"`
        if [ ! -z $j ];then
          k=`expr $j - 1`
        else
          k=-99
        fi

        if [[ $line -eq $k ]];then

					NUMBER_1=$line
					NUMBER_2=$(cat ${TMP_DIR}/${date}_list | sort | awk "NR == $i")

          # get the center longitude of the end of orbit scene
          CENT_LONG=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT Min(ST_X(ST_Centroid(geometry))) FROM \"${TMP_INV_BASE}\" WHERE Track = ${NUMBER_1}" | grep Min | awk -F '\= ' '{print $2}'`

          # where track number is higher and center longitude is betweeen
    	    ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "UPDATE \"${TMP_INV_BASE}\" SET Track=${NUMBER_1}
        																								   WHERE (Track=${NUMBER_2})
         																								   AND ( ST_X(ST_Centroid(geometry)) BETWEEN ${CENT_LONG} - 5 AND ${CENT_LONG} + 5 )"

        fi
      done
      rm ${TMP_DIR}/${date}_list*

		fi
	done
}

function check_homogeneous_coverage() {

	if [ -z "$3" ]; then
					echo " Missing arguments. Syntax:"
					echo " check_homogeneous_coverag	e <OST inventory shapefile> <temp-folder> <outfile> "
					return
	fi

	TMP_INV_FILE=$(readlink -f $1)
	TMP_INV_BASE=$(basename ${TMP_INV_FILE} | rev | cut -c 5- | rev)
	TMP_DIR=$(readlink -f $2)
	OUT_SHAPE=$(readlink -f $3)

	# get number of tracks
	NR_OF_TRACKS=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT TRACK FROM \"${TMP_INV_BASE}\"" | grep Track | wc -l`
  echo "Total track number: $NR_OF_TRACKS"
	# get first acq. date
	FIRST_ACQ=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT Min(Date) FROM \"${TMP_INV_BASE}\"" | grep "Min(Date)" | awk -F '\= ' '{print $2}'`

	# get last acq date
	LAST_ACQ=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT Max(Date) FROM \"${TMP_INV_BASE}\"" | grep "Max(Date)" | awk -F '\= ' '{print $2}'`

	# we start counting mosaics
	i=0

  #loop over the complete time period
	while [[ ${FIRST_ACQ} -lt ${LAST_ACQ} ]];do

		# determine end of cycle by 5 days
		END_OF_CYCLE=`date -d "${FIRST_ACQ}+5 days" +%Y%m%d`

		# number of tracks in specific date range range
		PERIOD_TRACK=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT TRACK FROM \"${TMP_INV_BASE}\"
																				                           WHERE \"Date\" BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE}" | grep Track | wc -l`

    echo "6 day: $PERIOD_TRACK"
    echo "checking from $FIRST_ACQ until $END_OF_CYCLE"
		# number of tracks for the period are not the same as overall, discard scenes of this period
		if [[ ${PERIOD_TRACK} -eq ${NR_OF_TRACKS} ]];then

			echo "INFO: I've just found a mosaic in a 6 days repeat cycle. FA: ${FIRST_ACQ} EC: ${END_OF_CYCLE}"
			# we count another full mosaic
			i=`expr $i + 1`

			# we write the acquisitions to the shapefile
			ogr2ogr -f 'ESRI Shapefile' ${OUT_SHAPE} ${TMP_INV_FILE} -append -dialect sqlite \
							-sql "SELECT * FROM \"${TMP_INV_BASE}\" WHERE \"Date\" BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE}"

			# write out to textfile for GEE import
			ogrinfo -q ${TMP_INV_FILE} -dialect sqlite \
							-sql "SELECT * FROM \"${TMP_INV_BASE}\" WHERE \"Date\" BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE}"

			# we overwrite first acq date to the next cycle
			FIRST_ACQ=`date -d "${FIRST_ACQ}+6 days" +%Y%m%d`

		else

			# we define a 12 day repeat cycle
			END_OF_CYCLE=`date -d "${FIRST_ACQ}+11 days" +%Y%m%d`

			# number of tracks in specific date range range
			PERIOD_TRACK=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT TRACK FROM \"${TMP_INV_BASE}\"
																																		 WHERE \"Date\" BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE}" | grep Track | wc -l`

      echo "12 day: $PERIOD_TRACK"
      echo "checking from $FIRST_ACQ until $END_OF_CYCLE"

			if [[ ${PERIOD_TRACK} -eq ${NR_OF_TRACKS} ]];then

				echo "INFO: I've just found a mosaic in a 12 days repeat cycle. FA: ${FIRST_ACQ} EC: ${END_OF_CYCLE}"
				# we count another full mosaic
				i=`expr $i + 1`

				# we write the 12 day repeat mosaic to the shapefile
				ogr2ogr -f 'ESRI Shapefile' ${OUT_SHAPE} ${TMP_INV_FILE} -append -dialect sqlite \
								-sql "SELECT * FROM \"${TMP_INV_BASE}\"
											WHERE (Date IN
												(SELECT Date FROM \"${TMP_INV_BASE}\"
													WHERE Date BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE} GROUP BY Track))
											AND (Track + Date IN
												(SELECT Track + Date FROM \"${TMP_INV_BASE}\"
													WHERE Date BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE} GROUP BY Track))"

				# write out to textfile for GEE import
				ogrinfo -q ${TMP_INV_FILE} -dialect sqlite \
				        -sql "SELECT Scene_Id FROM \"${TMP_INV_BASE}\"
				              WHERE (Date IN
				                (SELECT Date FROM \"${TMP_INV_BASE}\"
				                  WHERE Date BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE} GROUP BY Track))
				              AND (Track + Date IN
				                (SELECT Track + Date FROM \"${TMP_INV_BASE}\"
				                  WHERE Date BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE} GROUP BY Track))" | grep "Scene_ID" | awk -F '\=' '{print $2}' >> ${OUT_SHAPE}.csv
													echo "MOSAIC_END" >> ${OUT_SHAPE}.csv

				# we update our first acquisition
				FIRST_ACQ=`date -d "${FIRST_ACQ}+12 days" +%Y%m%d`

			else # we go for 24 days

				# we define a 12 day repeat cycle
				END_OF_CYCLE=`date -d "${FIRST_ACQ}+23 days" +%Y%m%d`

				# number of tracks in specific date range range
				PERIOD_TRACK=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT TRACK FROM \"${TMP_INV_BASE}\"
																																			 WHERE \"Date\" BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE}" | grep Track | wc -l`
        echo "24 day: $PERIOD_TRACK"
        echo "checking from $FIRST_ACQ until $END_OF_CYCLE"

				if [[ ${PERIOD_TRACK} -eq ${NR_OF_TRACKS} ]];then

					echo "INFO: I've just found a mosaic in a 24 days repeat cycle. FA: ${FIRST_ACQ} EC: ${END_OF_CYCLE}"
					# we count another full mosaic
					i=`expr $i + 1`

					# we write the 12 day repeat mosaic to the shapefile
					ogr2ogr -f 'ESRI Shapefile' ${OUT_SHAPE} ${TMP_INV_FILE} -append -dialect sqlite \
									-sql "SELECT * FROM \"${TMP_INV_BASE}\"
												WHERE (Date IN
													(SELECT Date FROM \"${TMP_INV_BASE}\"
													 WHERE Date BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE} GROUP BY Track))
												AND (Track + Date IN
													(SELECT Track + Date FROM \"${TMP_INV_BASE}\"
													 WHERE Date BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE} GROUP BY Track))"

					# write out to textfile for GEE import
					 ogrinfo -q ${TMP_INV_FILE} -dialect sqlite \
					 				-sql "SELECT Scene_Id FROM \"${TMP_INV_BASE}\"
					 							WHERE (Date IN
					 								(SELECT Date FROM \"${TMP_INV_BASE}\"
					 									WHERE Date BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE} GROUP BY Track))
					 							AND (Track + Date IN
					 								(SELECT Track + Date FROM \"${TMP_INV_BASE}\"
					 									WHERE Date BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE} GROUP BY Track))" | grep "Scene_ID" | awk -F '\=' '{print $2}' >> ${OUT_SHAPE}.csv
					 									echo "MOSAIC_END" >> ${OUT_SHAPE}.csv

					 # we update our first acquisition with 24 days
					 FIRST_ACQ=`date -d "${FIRST_ACQ}+24 days" +%Y%m%d`

				 else

					 #echo "INFO: I haven't found a mosaic in the 24 days repeat cycle. FA: ${FIRST_ACQ} EC: ${END_OF_CYCLE}"
					 # we update our first acquisition with 24 days
					 FIRST_ACQ=`date -d "${FIRST_ACQ}+1 days" +%Y%m%d` # maybe here we could do 1 day in order to get all possibilities

				 fi
			fi # close the 12 days if
		fi # close the 6 days if
	done

	if [[ $i -eq 0 ]];then
		echo " No valid mosaics. "
	else
		echo " Found $i valid mosaics for `basename ${TMP_INV_FILE}`. "
	fi
}

function rename_splitted_tracks() {

  if [ -z "$2" ]; then
          echo " Missing arguments. Syntax:"
          echo " rename_double_tracks <OST inventory shape> <temp-folder>"
          return
  fi

  TMP_INV_FILE=$(readlink -f $1)
  TMP_INV_BASE=$(basename ${TMP_INV_FILE} | rev | cut -c 5- | rev)
  TMP_DIR=$(readlink -f $2)

  # TBD
  # take center longitude of track with some margin, if 2 have significant different numbers treat them
  ogrinfo -q ${TMP_INV_FILE} -sql "SELECT DISTINCT Date FROM \"${TMP_INV_BASE}\" " | grep Date | awk -F '\= ' '{print $2}' > ${TMP_DIR}/date_list

  cat ${TMP_DIR}/date_list | while read date;do

    # create a lst of tracks
    ogrinfo -q ${TMP_INV_FILE} -sql "SELECT DISTINCT Track FROM \"${TMP_INV_BASE}\" WHERE Date = ${date} " | grep Track | awk -F '\= ' '{print $2}' > ${TMP_DIR}/track_list

    cat ${TMP_DIR}/track_list | while read track;do

      ogrinfo -q ${TMP_INV_FILE} -dialect sqlite \
              -sql "SELECT \"Start_Time\",Track FROM \"${TMP_INV_BASE}\"
                    WHERE (Date = ${date})
                    AND (Track = ${track})
                    AND (Start_Time NOT IN (SELECT Stop_Time
                                            FROM \"${TMP_INV_BASE}\"
                                            WHERE (Date = ${date})
                                            AND (Track = ${track})))" | grep Start_Time | awk -F '\= ' '{print $2}' > ${TMP_DIR}/starts
      cat ${TMP_DIR}/starts | sort
      echo starts

      if [ `cat ${TMP_DIR}/starts | wc -l` -gt 1 ];then

        ogrinfo -q ${TMP_INV_FILE} -dialect sqlite \
                 -sql "SELECT \"Stop_Time\" FROM \"${TMP_INV_BASE}\"
                       WHERE (Date = ${date})
                       AND (Stop_Time NOT IN (SELECT Start_Time
                                              FROM \"${TMP_INV_BASE}\"
                                              WHERE (Date = ${date})
                                              AND (Track = ${track})))" | grep Stop_Time | awk -F '\= ' '{print $2}' >> ${TMP_DIR}/starts


								# do a check if consecutive numbers appear
				cat ${TMP_DIR}/starts | sort > ${TMP_DIR}/starts_sorted
				LINES=$(cat ${TMP_DIR}/starts_sorted | head -n -1 | wc -l)

				i=2
				while [ $i -lt ${LINES} ];do

					DATE_1=`awk "NR == $i" ${TMP_DIR}/starts_sorted`
					DATE_2=`awk "NR == $i + 1" ${TMP_DIR}/starts_sorted`

					if [ ! -z "${DATE_2}" ];then

						if [[ `expr ${DATE_2} - ${DATE_1}` > 1 ]];then

							i=`expr $i + 2`

						else

							j=`expr $i + 1`
							sed -i "${i},${j}d" ${TMP_DIR}/starts_sorted

						fi
					else

						i=`expr $i + 2`
					fi
				done


				i=0
				if [ `cat ${TMP_DIR}/starts_sorted | wc -l` -gt 2 ];then

          cat ${TMP_DIR}/starts_sorted | head -n -1 | while read starts;do

						i=`expr $i + 1`

						# only get every second line (i.e. if line number is odd)
						if [ $((i%2)) -ne 0 ]; then
							STARTTIME=${starts}
							ENDTIME=`awk "NR == $i + 1" ${TMP_DIR}/starts_sorted`

							ogrinfo -q ${TMP_INV_FILE} -dialect sqlite \
							 				-sql "UPDATE \"${TMP_INV_BASE}\" SET Track=9${i}${track}
														WHERE (Date = ${date})
														AND (Track=${track})
														AND ( Start_Time BETWEEN ${STARTTIME} AND ${ENDTIME} )"
						fi
					done

				fi
			fi
		done
	done
}

function check_homogeneous_coverage2() {

	if [ -z "$3" ]; then
					echo " Missing arguments. Syntax:"
					echo " check_homogeneous_coverag	e <OST inventory shapefile> <temp-folder> <outfile> "
					return
	fi

	TMP_INV_FILE=$(readlink -f $1)
	TMP_INV_BASE=$(basename ${TMP_INV_FILE} | rev | cut -c 5- | rev)
	TMP_DIR=$(readlink -f $2)
	OUT_SHAPE=$(readlink -f $3)

	# get number of tracks
	NR_OF_TRACKS=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT TRACK FROM \"${TMP_INV_BASE}\"" | grep Track | wc -l`

	# get first acq. date
	FIRST_ACQ=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT Min(Date) FROM \"${TMP_INV_BASE}\"" | grep "Min(Date)" | awk -F '\= ' '{print $2}'`

	# get last acq date
	LAST_ACQ=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT Max(Date) FROM \"${TMP_INV_BASE}\"" | grep "Max(Date)" | awk -F '\= ' '{print $2}'`

	# we start counting mosaics
	i=0

  # create a datelist to loop over
  ogrinfo -q ${TMP_INV_FILE} -sql "SELECT DISTINCT Date FROM \"${TMP_INV_BASE}\" " | grep Date | awk -F '\= ' '{print $2}' | sort > ${TMP_DIR}/date_list

  # loop through dates
  cat ${TMP_DIR}/date_list | while read date; do

    # write date to a new datelist for the mosaic period
    echo $date >> ${TMP_DIR}/date_list_mosaic
    echo $date
    END_OF_CYCLE=${date}

    # number of tracks in specific date range range
    PERIOD_TRACK=`ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT TRACK FROM \"${TMP_INV_BASE}\"
                                                                   WHERE \"Date\" BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE}" | grep Track | wc -l`

    if [[ ${PERIOD_TRACK} -eq ${NR_OF_TRACKS} ]];then

      echo $PERIOD_TRACK
      touch ${TMP_DIR}/track_list_mosaic

      cat ${TMP_DIR}/date_list_mosaic | sort -r | while read date_inv; do


        echo $date_inv
        #ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT TRACK FROM \"${TMP_INV_BASE}\"
        #                                                 WHERE \"Date\" = ${date_inv}" | grep Track | awk -F '\= ' '{print $2}'
        # write out track number to a file
        ogrinfo -q ${TMP_INV_FILE} -dialect sqlite -sql "SELECT DISTINCT TRACK FROM \"${TMP_INV_BASE}\"
                                                         WHERE \"Date\" = ${date_inv}" | grep Track | awk -F '\= ' '{print $2}' > ${TMP_DIR}/track_list_mosaic_1
        cat ${TMP_DIR}/track_list_mosaic_1
        cat ${TMP_DIR}/track_list_mosaic_1 | while read line; do

          if ! grep -q "Track $line" ${TMP_DIR}/track_list_mosaic ; then
            echo "Track ${line} ${date_inv}" >> ${TMP_DIR}/track_list_mosaic
            # we write the acquisitions to the shapefile
            ogr2ogr -f 'ESRI Shapefile' ${OUT_SHAPE} ${TMP_INV_FILE} -append -dialect sqlite \
                    -sql "SELECT * FROM \"${TMP_INV_BASE}\" WHERE (\"Date\" = ${date_inv}) AND (\"Track\" = ${line})"

            # write out to textfile for GEE import
            #ogrinfo -q ${TMP_INV_FILE} -dialect sqlite \
            #        -sql "SELECT Scene_ID FROM \"${TMP_INV_BASE}\" WHERE \"Date\" BETWEEN ${FIRST_ACQ} AND ${END_OF_CYCLE}" >> ${OUT_SHAPE}.csv
          fi

        done
       done

      # we overwrite first acq date for the next cycle
      FIRST_ACQ=`date -d "${date}+1 days" +%Y%m%d`

      # remove temporary datelist
      rm -f ${TMP_DIR}/date_list_mosaic ${TMP_DIR}/track_list_mosaic
    fi
  done
}
